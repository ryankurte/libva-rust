#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

/* Turn off "improper_ctypes" warning,
 * See https://github.com/rust-lang/rust/issues/34798
 */
#![allow(improper_ctypes)]

/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const _STDINT_H: ::std::os::raw::c_uint = 1;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201505;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 23;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const _BITS_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_int = -1;
pub const UINT_FAST32_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_uint = 0;
pub const WINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const VA_MAJOR_VERSION: ::std::os::raw::c_uint = 0;
pub const VA_MINOR_VERSION: ::std::os::raw::c_uint = 39;
pub const VA_MICRO_VERSION: ::std::os::raw::c_uint = 4;
pub const VA_VERSION_S: &'static [u8; 7usize] = b"0.39.4\x00";
pub const VA_VERSION_HEX: ::std::os::raw::c_uint = 2556928;
pub const VA_STATUS_SUCCESS: ::std::os::raw::c_uint = 0;
pub const VA_STATUS_ERROR_OPERATION_FAILED: ::std::os::raw::c_uint = 1;
pub const VA_STATUS_ERROR_ALLOCATION_FAILED: ::std::os::raw::c_uint = 2;
pub const VA_STATUS_ERROR_INVALID_DISPLAY: ::std::os::raw::c_uint = 3;
pub const VA_STATUS_ERROR_INVALID_CONFIG: ::std::os::raw::c_uint = 4;
pub const VA_STATUS_ERROR_INVALID_CONTEXT: ::std::os::raw::c_uint = 5;
pub const VA_STATUS_ERROR_INVALID_SURFACE: ::std::os::raw::c_uint = 6;
pub const VA_STATUS_ERROR_INVALID_BUFFER: ::std::os::raw::c_uint = 7;
pub const VA_STATUS_ERROR_INVALID_IMAGE: ::std::os::raw::c_uint = 8;
pub const VA_STATUS_ERROR_INVALID_SUBPICTURE: ::std::os::raw::c_uint = 9;
pub const VA_STATUS_ERROR_ATTR_NOT_SUPPORTED: ::std::os::raw::c_uint = 10;
pub const VA_STATUS_ERROR_MAX_NUM_EXCEEDED: ::std::os::raw::c_uint = 11;
pub const VA_STATUS_ERROR_UNSUPPORTED_PROFILE: ::std::os::raw::c_uint = 12;
pub const VA_STATUS_ERROR_UNSUPPORTED_ENTRYPOINT: ::std::os::raw::c_uint = 13;
pub const VA_STATUS_ERROR_UNSUPPORTED_RT_FORMAT: ::std::os::raw::c_uint = 14;
pub const VA_STATUS_ERROR_UNSUPPORTED_BUFFERTYPE: ::std::os::raw::c_uint = 15;
pub const VA_STATUS_ERROR_SURFACE_BUSY: ::std::os::raw::c_uint = 16;
pub const VA_STATUS_ERROR_FLAG_NOT_SUPPORTED: ::std::os::raw::c_uint = 17;
pub const VA_STATUS_ERROR_INVALID_PARAMETER: ::std::os::raw::c_uint = 18;
pub const VA_STATUS_ERROR_RESOLUTION_NOT_SUPPORTED: ::std::os::raw::c_uint =
    19;
pub const VA_STATUS_ERROR_UNIMPLEMENTED: ::std::os::raw::c_uint = 20;
pub const VA_STATUS_ERROR_SURFACE_IN_DISPLAYING: ::std::os::raw::c_uint = 21;
pub const VA_STATUS_ERROR_INVALID_IMAGE_FORMAT: ::std::os::raw::c_uint = 22;
pub const VA_STATUS_ERROR_DECODING_ERROR: ::std::os::raw::c_uint = 23;
pub const VA_STATUS_ERROR_ENCODING_ERROR: ::std::os::raw::c_uint = 24;
pub const VA_STATUS_ERROR_INVALID_VALUE: ::std::os::raw::c_uint = 25;
pub const VA_STATUS_ERROR_UNSUPPORTED_FILTER: ::std::os::raw::c_uint = 32;
pub const VA_STATUS_ERROR_INVALID_FILTER_CHAIN: ::std::os::raw::c_uint = 33;
pub const VA_STATUS_ERROR_HW_BUSY: ::std::os::raw::c_uint = 34;
pub const VA_STATUS_ERROR_UNSUPPORTED_MEMORY_TYPE: ::std::os::raw::c_uint =
    36;
pub const VA_STATUS_ERROR_UNKNOWN: ::std::os::raw::c_uint = 4294967295;
pub const VA_FRAME_PICTURE: ::std::os::raw::c_uint = 0;
pub const VA_TOP_FIELD: ::std::os::raw::c_uint = 1;
pub const VA_BOTTOM_FIELD: ::std::os::raw::c_uint = 2;
pub const VA_ENABLE_BLEND: ::std::os::raw::c_uint = 4;
pub const VA_CLEAR_DRAWABLE: ::std::os::raw::c_uint = 8;
pub const VA_SRC_COLOR_MASK: ::std::os::raw::c_uint = 240;
pub const VA_SRC_BT601: ::std::os::raw::c_uint = 16;
pub const VA_SRC_BT709: ::std::os::raw::c_uint = 32;
pub const VA_SRC_SMPTE_240: ::std::os::raw::c_uint = 64;
pub const VA_FILTER_SCALING_DEFAULT: ::std::os::raw::c_uint = 0;
pub const VA_FILTER_SCALING_FAST: ::std::os::raw::c_uint = 256;
pub const VA_FILTER_SCALING_HQ: ::std::os::raw::c_uint = 512;
pub const VA_FILTER_SCALING_NL_ANAMORPHIC: ::std::os::raw::c_uint = 768;
pub const VA_FILTER_SCALING_MASK: ::std::os::raw::c_uint = 3840;
pub const VA_RT_FORMAT_YUV420: ::std::os::raw::c_uint = 1;
pub const VA_RT_FORMAT_YUV422: ::std::os::raw::c_uint = 2;
pub const VA_RT_FORMAT_YUV444: ::std::os::raw::c_uint = 4;
pub const VA_RT_FORMAT_YUV411: ::std::os::raw::c_uint = 8;
pub const VA_RT_FORMAT_YUV400: ::std::os::raw::c_uint = 16;
pub const VA_RT_FORMAT_YUV420_10BPP: ::std::os::raw::c_uint = 256;
pub const VA_RT_FORMAT_RGB16: ::std::os::raw::c_uint = 65536;
pub const VA_RT_FORMAT_RGB32: ::std::os::raw::c_uint = 131072;
pub const VA_RT_FORMAT_RGBP: ::std::os::raw::c_uint = 1048576;
pub const VA_RT_FORMAT_PROTECTED: ::std::os::raw::c_uint = 2147483648;
pub const VA_RC_NONE: ::std::os::raw::c_uint = 1;
pub const VA_RC_CBR: ::std::os::raw::c_uint = 2;
pub const VA_RC_VBR: ::std::os::raw::c_uint = 4;
pub const VA_RC_VCM: ::std::os::raw::c_uint = 8;
pub const VA_RC_CQP: ::std::os::raw::c_uint = 16;
pub const VA_RC_VBR_CONSTRAINED: ::std::os::raw::c_uint = 32;
pub const VA_RC_MB: ::std::os::raw::c_uint = 128;
pub const VA_DEC_SLICE_MODE_NORMAL: ::std::os::raw::c_uint = 1;
pub const VA_DEC_SLICE_MODE_BASE: ::std::os::raw::c_uint = 2;
pub const VA_ENC_PACKED_HEADER_NONE: ::std::os::raw::c_uint = 0;
pub const VA_ENC_PACKED_HEADER_SEQUENCE: ::std::os::raw::c_uint = 1;
pub const VA_ENC_PACKED_HEADER_PICTURE: ::std::os::raw::c_uint = 2;
pub const VA_ENC_PACKED_HEADER_SLICE: ::std::os::raw::c_uint = 4;
pub const VA_ENC_PACKED_HEADER_MISC: ::std::os::raw::c_uint = 8;
pub const VA_ENC_PACKED_HEADER_RAW_DATA: ::std::os::raw::c_uint = 16;
pub const VA_ENC_INTERLACED_NONE: ::std::os::raw::c_uint = 0;
pub const VA_ENC_INTERLACED_FRAME: ::std::os::raw::c_uint = 1;
pub const VA_ENC_INTERLACED_FIELD: ::std::os::raw::c_uint = 2;
pub const VA_ENC_INTERLACED_MBAFF: ::std::os::raw::c_uint = 4;
pub const VA_ENC_INTERLACED_PAFF: ::std::os::raw::c_uint = 8;
pub const VA_ENC_SLICE_STRUCTURE_ARBITRARY_ROWS: ::std::os::raw::c_uint = 0;
pub const VA_ENC_SLICE_STRUCTURE_POWER_OF_TWO_ROWS: ::std::os::raw::c_uint =
    1;
pub const VA_ENC_SLICE_STRUCTURE_ARBITRARY_MACROBLOCKS: ::std::os::raw::c_uint
          =
    2;
pub const VA_ATTRIB_NOT_SUPPORTED: ::std::os::raw::c_uint = 2147483648;
pub const VA_INVALID_ID: ::std::os::raw::c_uint = 4294967295;
pub const VA_INVALID_SURFACE: ::std::os::raw::c_uint = 4294967295;
pub const VA_SURFACE_ATTRIB_NOT_SUPPORTED: ::std::os::raw::c_uint = 0;
pub const VA_SURFACE_ATTRIB_GETTABLE: ::std::os::raw::c_uint = 1;
pub const VA_SURFACE_ATTRIB_SETTABLE: ::std::os::raw::c_uint = 2;
pub const VA_SURFACE_ATTRIB_MEM_TYPE_VA: ::std::os::raw::c_uint = 1;
pub const VA_SURFACE_ATTRIB_MEM_TYPE_V4L2: ::std::os::raw::c_uint = 2;
pub const VA_SURFACE_ATTRIB_MEM_TYPE_USER_PTR: ::std::os::raw::c_uint = 4;
pub const VA_SURFACE_EXTBUF_DESC_ENABLE_TILING: ::std::os::raw::c_uint = 1;
pub const VA_SURFACE_EXTBUF_DESC_CACHED: ::std::os::raw::c_uint = 2;
pub const VA_SURFACE_EXTBUF_DESC_UNCACHED: ::std::os::raw::c_uint = 4;
pub const VA_SURFACE_EXTBUF_DESC_WC: ::std::os::raw::c_uint = 8;
pub const VA_SURFACE_EXTBUF_DESC_PROTECTED: ::std::os::raw::c_uint =
    2147483648;
pub const VA_SURFACE_ATTRIB_USAGE_HINT_GENERIC: ::std::os::raw::c_uint = 0;
pub const VA_SURFACE_ATTRIB_USAGE_HINT_DECODER: ::std::os::raw::c_uint = 1;
pub const VA_SURFACE_ATTRIB_USAGE_HINT_ENCODER: ::std::os::raw::c_uint = 2;
pub const VA_SURFACE_ATTRIB_USAGE_HINT_VPP_READ: ::std::os::raw::c_uint = 4;
pub const VA_SURFACE_ATTRIB_USAGE_HINT_VPP_WRITE: ::std::os::raw::c_uint = 8;
pub const VA_SURFACE_ATTRIB_USAGE_HINT_DISPLAY: ::std::os::raw::c_uint = 16;
pub const VA_PROGRESSIVE: ::std::os::raw::c_uint = 1;
pub const VA_SLICE_DATA_FLAG_ALL: ::std::os::raw::c_uint = 0;
pub const VA_SLICE_DATA_FLAG_BEGIN: ::std::os::raw::c_uint = 1;
pub const VA_SLICE_DATA_FLAG_MIDDLE: ::std::os::raw::c_uint = 2;
pub const VA_SLICE_DATA_FLAG_END: ::std::os::raw::c_uint = 4;
pub const VA_MB_TYPE_MOTION_FORWARD: ::std::os::raw::c_uint = 2;
pub const VA_MB_TYPE_MOTION_BACKWARD: ::std::os::raw::c_uint = 4;
pub const VA_MB_TYPE_MOTION_PATTERN: ::std::os::raw::c_uint = 8;
pub const VA_MB_TYPE_MOTION_INTRA: ::std::os::raw::c_uint = 16;
pub const VA_PICTURE_H264_INVALID: ::std::os::raw::c_uint = 1;
pub const VA_PICTURE_H264_TOP_FIELD: ::std::os::raw::c_uint = 2;
pub const VA_PICTURE_H264_BOTTOM_FIELD: ::std::os::raw::c_uint = 4;
pub const VA_PICTURE_H264_SHORT_TERM_REFERENCE: ::std::os::raw::c_uint = 8;
pub const VA_PICTURE_H264_LONG_TERM_REFERENCE: ::std::os::raw::c_uint = 16;
pub const VA_CODED_BUF_STATUS_PICTURE_AVE_QP_MASK: ::std::os::raw::c_uint =
    255;
pub const VA_CODED_BUF_STATUS_LARGE_SLICE_MASK: ::std::os::raw::c_uint = 256;
pub const VA_CODED_BUF_STATUS_SLICE_OVERFLOW_MASK: ::std::os::raw::c_uint =
    512;
pub const VA_CODED_BUF_STATUS_BITRATE_OVERFLOW: ::std::os::raw::c_uint = 1024;
pub const VA_CODED_BUF_STATUS_BITRATE_HIGH: ::std::os::raw::c_uint = 2048;
pub const VA_CODED_BUF_STATUS_FRAME_SIZE_OVERFLOW: ::std::os::raw::c_uint =
    4096;
pub const VA_CODED_BUF_STATUS_AIR_MB_OVER_THRESHOLD: ::std::os::raw::c_uint =
    16711680;
pub const VA_CODED_BUF_STATUS_SINGLE_NALU: ::std::os::raw::c_uint = 268435456;
pub const VA_FOURCC_NV12: ::std::os::raw::c_uint = 842094158;
pub const VA_FOURCC_AI44: ::std::os::raw::c_uint = 875839817;
pub const VA_FOURCC_RGBA: ::std::os::raw::c_uint = 1094862674;
pub const VA_FOURCC_RGBX: ::std::os::raw::c_uint = 1480738642;
pub const VA_FOURCC_BGRA: ::std::os::raw::c_uint = 1095911234;
pub const VA_FOURCC_BGRX: ::std::os::raw::c_uint = 1481787202;
pub const VA_FOURCC_ARGB: ::std::os::raw::c_uint = 1111970369;
pub const VA_FOURCC_XRGB: ::std::os::raw::c_uint = 1111970392;
pub const VA_FOURCC_ABGR: ::std::os::raw::c_uint = 1380401729;
pub const VA_FOURCC_XBGR: ::std::os::raw::c_uint = 1380401752;
pub const VA_FOURCC_UYVY: ::std::os::raw::c_uint = 1498831189;
pub const VA_FOURCC_YUY2: ::std::os::raw::c_uint = 844715353;
pub const VA_FOURCC_AYUV: ::std::os::raw::c_uint = 1448433985;
pub const VA_FOURCC_NV11: ::std::os::raw::c_uint = 825316942;
pub const VA_FOURCC_YV12: ::std::os::raw::c_uint = 842094169;
pub const VA_FOURCC_P208: ::std::os::raw::c_uint = 942682704;
pub const VA_FOURCC_IYUV: ::std::os::raw::c_uint = 1448433993;
pub const VA_FOURCC_YV24: ::std::os::raw::c_uint = 875714137;
pub const VA_FOURCC_YV32: ::std::os::raw::c_uint = 842225241;
pub const VA_FOURCC_Y800: ::std::os::raw::c_uint = 808466521;
pub const VA_FOURCC_IMC3: ::std::os::raw::c_uint = 860048713;
pub const VA_FOURCC_411P: ::std::os::raw::c_uint = 1345401140;
pub const VA_FOURCC_422H: ::std::os::raw::c_uint = 1211249204;
pub const VA_FOURCC_422V: ::std::os::raw::c_uint = 1446130228;
pub const VA_FOURCC_444P: ::std::os::raw::c_uint = 1345598516;
pub const VA_FOURCC_RGBP: ::std::os::raw::c_uint = 1346520914;
pub const VA_FOURCC_BGRP: ::std::os::raw::c_uint = 1347569474;
pub const VA_FOURCC_411R: ::std::os::raw::c_uint = 1378955572;
pub const VA_FOURCC_YV16: ::std::os::raw::c_uint = 909203033;
pub const VA_FOURCC_P010: ::std::os::raw::c_uint = 808530000;
pub const VA_FOURCC_P016: ::std::os::raw::c_uint = 909193296;
pub const VA_LSB_FIRST: ::std::os::raw::c_uint = 1;
pub const VA_MSB_FIRST: ::std::os::raw::c_uint = 2;
pub const VA_SUBPICTURE_CHROMA_KEYING: ::std::os::raw::c_uint = 1;
pub const VA_SUBPICTURE_GLOBAL_ALPHA: ::std::os::raw::c_uint = 2;
pub const VA_SUBPICTURE_DESTINATION_IS_SCREEN_COORD: ::std::os::raw::c_uint =
    4;
pub const VA_ROTATION_NONE: ::std::os::raw::c_uint = 0;
pub const VA_ROTATION_90: ::std::os::raw::c_uint = 1;
pub const VA_ROTATION_180: ::std::os::raw::c_uint = 2;
pub const VA_ROTATION_270: ::std::os::raw::c_uint = 3;
pub const VA_OOL_DEBLOCKING_FALSE: ::std::os::raw::c_uint = 0;
pub const VA_OOL_DEBLOCKING_TRUE: ::std::os::raw::c_uint = 1;
pub const VA_RENDER_MODE_UNDEFINED: ::std::os::raw::c_uint = 0;
pub const VA_RENDER_MODE_LOCAL_OVERLAY: ::std::os::raw::c_uint = 1;
pub const VA_RENDER_MODE_LOCAL_GPU: ::std::os::raw::c_uint = 2;
pub const VA_RENDER_MODE_EXTERNAL_OVERLAY: ::std::os::raw::c_uint = 4;
pub const VA_RENDER_MODE_EXTERNAL_GPU: ::std::os::raw::c_uint = 8;
pub const VA_RENDER_DEVICE_UNDEFINED: ::std::os::raw::c_uint = 0;
pub const VA_RENDER_DEVICE_LOCAL: ::std::os::raw::c_uint = 1;
pub const VA_RENDER_DEVICE_EXTERNAL: ::std::os::raw::c_uint = 2;
pub const VA_DISPLAY_ATTRIB_NOT_SUPPORTED: ::std::os::raw::c_uint = 0;
pub const VA_DISPLAY_ATTRIB_GETTABLE: ::std::os::raw::c_uint = 1;
pub const VA_DISPLAY_ATTRIB_SETTABLE: ::std::os::raw::c_uint = 2;
pub const VA_PICTURE_HEVC_INVALID: ::std::os::raw::c_uint = 1;
pub const VA_PICTURE_HEVC_FIELD_PIC: ::std::os::raw::c_uint = 2;
pub const VA_PICTURE_HEVC_BOTTOM_FIELD: ::std::os::raw::c_uint = 4;
pub const VA_PICTURE_HEVC_LONG_TERM_REFERENCE: ::std::os::raw::c_uint = 8;
pub const VA_PICTURE_HEVC_RPS_ST_CURR_BEFORE: ::std::os::raw::c_uint = 16;
pub const VA_PICTURE_HEVC_RPS_ST_CURR_AFTER: ::std::os::raw::c_uint = 32;
pub const VA_PICTURE_HEVC_RPS_LT_CURR: ::std::os::raw::c_uint = 64;
pub const HEVC_LAST_PICTURE_EOSEQ: ::std::os::raw::c_uint = 1;
pub const HEVC_LAST_PICTURE_EOSTREAM: ::std::os::raw::c_uint = 2;
pub const H264_LAST_PICTURE_EOSEQ: ::std::os::raw::c_uint = 1;
pub const H264_LAST_PICTURE_EOSTREAM: ::std::os::raw::c_uint = 2;
pub const VA_MB_PRED_AVAIL_TOP_LEFT: ::std::os::raw::c_uint = 4;
pub const VA_MB_PRED_AVAIL_TOP: ::std::os::raw::c_uint = 16;
pub const VA_MB_PRED_AVAIL_TOP_RIGHT: ::std::os::raw::c_uint = 8;
pub const VA_MB_PRED_AVAIL_LEFT: ::std::os::raw::c_uint = 64;
pub const VA_PROC_PIPELINE_SUBPICTURES: ::std::os::raw::c_uint = 1;
pub const VA_PROC_PIPELINE_FAST: ::std::os::raw::c_uint = 2;
pub const VA_PROC_FILTER_MANDATORY: ::std::os::raw::c_uint = 1;
pub const VA_PIPELINE_FLAG_END: ::std::os::raw::c_uint = 4;
pub const VA_DEINTERLACING_BOTTOM_FIELD_FIRST: ::std::os::raw::c_uint = 1;
pub const VA_DEINTERLACING_BOTTOM_FIELD: ::std::os::raw::c_uint = 2;
pub const VA_DEINTERLACING_ONE_FIELD: ::std::os::raw::c_uint = 4;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_1 {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
impl Clone for _bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
pub type max_align_t = _bindgen_ty_1;
pub type int_least8_t = ::std::os::raw::c_char;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_char;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
/**
Overview 

The VA API is intended to provide an interface between a video decode/encode/display
application (client) and a hardware accelerator (server), to off-load 
video decode/encode/display operations from the host to the hardware accelerator at various 
entry-points.

The basic operation steps are:

- Negotiate a mutually acceptable configuration with the server to lock
  down profile, entrypoints, and other attributes that will not change on 
  a frame-by-frame basis.
- Create a decode context which represents a "virtualized" hardware decode 
  device
- Get and fill decode buffers with picture level, slice level and macroblock 
  level data (depending on entrypoints)
- Pass the decode buffers to the server to decode the current frame

Initialization & Configuration Management 

- Find out supported profiles
- Find out entrypoints for a given profile
- Find out configuration attributes for a given profile/entrypoint pair
- Create a configuration for use by the decoder

*/
pub type VADisplay = *mut ::std::os::raw::c_void;
pub type VAStatus = ::std::os::raw::c_int;
#[link(name = "va")]
extern "C" {
    /**
 * Returns a short english description of error_status
 */
    pub fn vaErrorStr(error_status: VAStatus)
     -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VARectangle {
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
    pub width: ::std::os::raw::c_ushort,
    pub height: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__VARectangle() {
    assert_eq!(::std::mem::size_of::<_VARectangle>() , 8usize);
    assert_eq!(::std::mem::align_of::<_VARectangle>() , 2usize);
}
impl Clone for _VARectangle {
    fn clone(&self) -> Self { *self }
}
pub type VARectangle = _VARectangle;
/**
 * Initialization:
 * A display must be obtained by calling vaGetDisplay() before calling
 * vaInitialize() and other functions. This connects the API to the 
 * native window system.
 * For X Windows, native_dpy would be from XOpenDisplay()
 */
pub type VANativeDisplay = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn vaDisplayIsValid(dpy: VADisplay) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *  Set the override driver name instead of queried driver driver.
 */
    pub fn vaSetDriverName(dpy: VADisplay,
                           driver_name: *mut ::std::os::raw::c_char)
     -> VAStatus;
}
extern "C" {
    /**
 * Initialize the library 
 */
    pub fn vaInitialize(dpy: VADisplay,
                        major_version: *mut ::std::os::raw::c_int,
                        minor_version: *mut ::std::os::raw::c_int)
     -> VAStatus;
}
extern "C" {
    /**
 * After this call, all library internal resources will be cleaned up
 */
    pub fn vaTerminate(dpy: VADisplay) -> VAStatus;
}
extern "C" {
    /**
 * vaQueryVendorString returns a pointer to a zero-terminated string
 * describing some aspects of the VA implemenation on a specific    
 * hardware accelerator. The format of the returned string is vendor
 * specific and at the discretion of the implementer.
 * e.g. for the Intel GMA500 implementation, an example would be:
 * "Intel GMA500 - 2.0.0.32L.0005"
 */
    pub fn vaQueryVendorString(dpy: VADisplay)
     -> *const ::std::os::raw::c_char;
}
pub type VAPrivFunc =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
extern "C" {
    /**
 * Return a function pointer given a function name in the library.
 * This allows private interfaces into the library
 */
    pub fn vaGetLibFunc(dpy: VADisplay, func: *const ::std::os::raw::c_char)
     -> VAPrivFunc;
}
pub const VAProfileNone: _bindgen_ty_2 = _bindgen_ty_2::VAProfileNone;
pub const VAProfileMPEG2Simple: _bindgen_ty_2 =
    _bindgen_ty_2::VAProfileMPEG2Simple;
pub const VAProfileMPEG2Main: _bindgen_ty_2 =
    _bindgen_ty_2::VAProfileMPEG2Main;
pub const VAProfileMPEG4Simple: _bindgen_ty_2 =
    _bindgen_ty_2::VAProfileMPEG4Simple;
pub const VAProfileMPEG4AdvancedSimple: _bindgen_ty_2 =
    _bindgen_ty_2::VAProfileMPEG4AdvancedSimple;
pub const VAProfileMPEG4Main: _bindgen_ty_2 =
    _bindgen_ty_2::VAProfileMPEG4Main;
pub const VAProfileH264Baseline: _bindgen_ty_2 =
    _bindgen_ty_2::VAProfileH264Baseline;
pub const VAProfileH264Main: _bindgen_ty_2 = _bindgen_ty_2::VAProfileH264Main;
pub const VAProfileH264High: _bindgen_ty_2 = _bindgen_ty_2::VAProfileH264High;
pub const VAProfileVC1Simple: _bindgen_ty_2 =
    _bindgen_ty_2::VAProfileVC1Simple;
pub const VAProfileVC1Main: _bindgen_ty_2 = _bindgen_ty_2::VAProfileVC1Main;
pub const VAProfileVC1Advanced: _bindgen_ty_2 =
    _bindgen_ty_2::VAProfileVC1Advanced;
pub const VAProfileH263Baseline: _bindgen_ty_2 =
    _bindgen_ty_2::VAProfileH263Baseline;
pub const VAProfileJPEGBaseline: _bindgen_ty_2 =
    _bindgen_ty_2::VAProfileJPEGBaseline;
pub const VAProfileH264ConstrainedBaseline: _bindgen_ty_2 =
    _bindgen_ty_2::VAProfileH264ConstrainedBaseline;
pub const VAProfileVP8Version0_3: _bindgen_ty_2 =
    _bindgen_ty_2::VAProfileVP8Version0_3;
pub const VAProfileH264MultiviewHigh: _bindgen_ty_2 =
    _bindgen_ty_2::VAProfileH264MultiviewHigh;
pub const VAProfileH264StereoHigh: _bindgen_ty_2 =
    _bindgen_ty_2::VAProfileH264StereoHigh;
pub const VAProfileHEVCMain: _bindgen_ty_2 = _bindgen_ty_2::VAProfileHEVCMain;
pub const VAProfileHEVCMain10: _bindgen_ty_2 =
    _bindgen_ty_2::VAProfileHEVCMain10;
pub const VAProfileVP9Profile0: _bindgen_ty_2 =
    _bindgen_ty_2::VAProfileVP9Profile0;
pub const VAProfileVP9Profile1: _bindgen_ty_2 =
    _bindgen_ty_2::VAProfileVP9Profile1;
pub const VAProfileVP9Profile2: _bindgen_ty_2 =
    _bindgen_ty_2::VAProfileVP9Profile2;
pub const VAProfileVP9Profile3: _bindgen_ty_2 =
    _bindgen_ty_2::VAProfileVP9Profile3;
#[repr(i32)]
/** Currently defined profiles */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    VAProfileNone = -1,
    VAProfileMPEG2Simple = 0,
    VAProfileMPEG2Main = 1,
    VAProfileMPEG4Simple = 2,
    VAProfileMPEG4AdvancedSimple = 3,
    VAProfileMPEG4Main = 4,
    VAProfileH264Baseline = 5,
    VAProfileH264Main = 6,
    VAProfileH264High = 7,
    VAProfileVC1Simple = 8,
    VAProfileVC1Main = 9,
    VAProfileVC1Advanced = 10,
    VAProfileH263Baseline = 11,
    VAProfileJPEGBaseline = 12,
    VAProfileH264ConstrainedBaseline = 13,
    VAProfileVP8Version0_3 = 14,
    VAProfileH264MultiviewHigh = 15,
    VAProfileH264StereoHigh = 16,
    VAProfileHEVCMain = 17,
    VAProfileHEVCMain10 = 18,
    VAProfileVP9Profile0 = 19,
    VAProfileVP9Profile1 = 20,
    VAProfileVP9Profile2 = 21,
    VAProfileVP9Profile3 = 22,
}
pub use self::_bindgen_ty_2 as VAProfile;
pub const VAEntrypointVLD: _bindgen_ty_3 = _bindgen_ty_3::VAEntrypointVLD;
pub const VAEntrypointIZZ: _bindgen_ty_3 = _bindgen_ty_3::VAEntrypointIZZ;
pub const VAEntrypointIDCT: _bindgen_ty_3 = _bindgen_ty_3::VAEntrypointIDCT;
pub const VAEntrypointMoComp: _bindgen_ty_3 =
    _bindgen_ty_3::VAEntrypointMoComp;
pub const VAEntrypointDeblocking: _bindgen_ty_3 =
    _bindgen_ty_3::VAEntrypointDeblocking;
pub const VAEntrypointEncSlice: _bindgen_ty_3 =
    _bindgen_ty_3::VAEntrypointEncSlice;
pub const VAEntrypointEncPicture: _bindgen_ty_3 =
    _bindgen_ty_3::VAEntrypointEncPicture;
pub const VAEntrypointEncSliceLP: _bindgen_ty_3 =
    _bindgen_ty_3::VAEntrypointEncSliceLP;
pub const VAEntrypointVideoProc: _bindgen_ty_3 =
    _bindgen_ty_3::VAEntrypointVideoProc;
#[repr(u32)]
/**
 *  Currently defined entrypoints 
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_3 {
    VAEntrypointVLD = 1,
    VAEntrypointIZZ = 2,
    VAEntrypointIDCT = 3,
    VAEntrypointMoComp = 4,
    VAEntrypointDeblocking = 5,
    VAEntrypointEncSlice = 6,
    VAEntrypointEncPicture = 7,
    VAEntrypointEncSliceLP = 8,
    VAEntrypointVideoProc = 10,
}
pub use self::_bindgen_ty_3 as VAEntrypoint;
pub const VAConfigAttribRTFormat: _bindgen_ty_4 =
    _bindgen_ty_4::VAConfigAttribRTFormat;
pub const VAConfigAttribSpatialResidual: _bindgen_ty_4 =
    _bindgen_ty_4::VAConfigAttribSpatialResidual;
pub const VAConfigAttribSpatialClipping: _bindgen_ty_4 =
    _bindgen_ty_4::VAConfigAttribSpatialClipping;
pub const VAConfigAttribIntraResidual: _bindgen_ty_4 =
    _bindgen_ty_4::VAConfigAttribIntraResidual;
pub const VAConfigAttribEncryption: _bindgen_ty_4 =
    _bindgen_ty_4::VAConfigAttribEncryption;
pub const VAConfigAttribRateControl: _bindgen_ty_4 =
    _bindgen_ty_4::VAConfigAttribRateControl;
pub const VAConfigAttribDecSliceMode: _bindgen_ty_4 =
    _bindgen_ty_4::VAConfigAttribDecSliceMode;
pub const VAConfigAttribEncPackedHeaders: _bindgen_ty_4 =
    _bindgen_ty_4::VAConfigAttribEncPackedHeaders;
pub const VAConfigAttribEncInterlaced: _bindgen_ty_4 =
    _bindgen_ty_4::VAConfigAttribEncInterlaced;
pub const VAConfigAttribEncMaxRefFrames: _bindgen_ty_4 =
    _bindgen_ty_4::VAConfigAttribEncMaxRefFrames;
pub const VAConfigAttribEncMaxSlices: _bindgen_ty_4 =
    _bindgen_ty_4::VAConfigAttribEncMaxSlices;
pub const VAConfigAttribEncSliceStructure: _bindgen_ty_4 =
    _bindgen_ty_4::VAConfigAttribEncSliceStructure;
pub const VAConfigAttribEncMacroblockInfo: _bindgen_ty_4 =
    _bindgen_ty_4::VAConfigAttribEncMacroblockInfo;
pub const VAConfigAttribEncJPEG: _bindgen_ty_4 =
    _bindgen_ty_4::VAConfigAttribEncJPEG;
pub const VAConfigAttribEncQualityRange: _bindgen_ty_4 =
    _bindgen_ty_4::VAConfigAttribEncQualityRange;
pub const VAConfigAttribEncSkipFrame: _bindgen_ty_4 =
    _bindgen_ty_4::VAConfigAttribEncSkipFrame;
pub const VAConfigAttribEncROI: _bindgen_ty_4 =
    _bindgen_ty_4::VAConfigAttribEncROI;
pub const VAConfigAttribTypeMax: _bindgen_ty_4 =
    _bindgen_ty_4::VAConfigAttribTypeMax;
#[repr(u32)]
/** Currently defined configuration attribute types */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_4 {
    VAConfigAttribRTFormat = 0,
    VAConfigAttribSpatialResidual = 1,
    VAConfigAttribSpatialClipping = 2,
    VAConfigAttribIntraResidual = 3,
    VAConfigAttribEncryption = 4,
    VAConfigAttribRateControl = 5,
    VAConfigAttribDecSliceMode = 6,
    VAConfigAttribEncPackedHeaders = 10,
    VAConfigAttribEncInterlaced = 11,
    VAConfigAttribEncMaxRefFrames = 13,
    VAConfigAttribEncMaxSlices = 14,
    VAConfigAttribEncSliceStructure = 15,
    VAConfigAttribEncMacroblockInfo = 16,
    VAConfigAttribEncJPEG = 20,
    VAConfigAttribEncQualityRange = 21,
    VAConfigAttribEncSkipFrame = 24,
    VAConfigAttribEncROI = 25,
    VAConfigAttribTypeMax = 26,
}
pub use self::_bindgen_ty_4 as VAConfigAttribType;
/**
 * Configuration attributes
 * If there is more than one value for an attribute, a default
 * value will be assigned to the attribute if the client does not
 * specify the attribute when creating a configuration
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAConfigAttrib {
    pub type_: VAConfigAttribType,
    pub value: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__VAConfigAttrib() {
    assert_eq!(::std::mem::size_of::<_VAConfigAttrib>() , 8usize);
    assert_eq!(::std::mem::align_of::<_VAConfigAttrib>() , 4usize);
}
impl Clone for _VAConfigAttrib {
    fn clone(&self) -> Self { *self }
}
pub type VAConfigAttrib = _VAConfigAttrib;
/** \brief Attribute value for VAConfigAttribEncJPEG */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAConfigAttribValEncJPEG {
    pub bits: __BindgenUnionField<_VAConfigAttribValEncJPEG__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAConfigAttribValEncJPEG__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__VAConfigAttribValEncJPEG__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAConfigAttribValEncJPEG__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAConfigAttribValEncJPEG__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAConfigAttribValEncJPEG__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAConfigAttribValEncJPEG__bindgen_ty_1 {
    #[inline]
    pub fn arithmatic_coding_mode(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_arithmatic_coding_mode(&mut self,
                                      val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn progressive_dct_mode(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_progressive_dct_mode(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn non_interleaved_mode(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_non_interleaved_mode(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn differential_mode(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                       3u32) as u32)
        }
    }
    #[inline]
    pub fn set_differential_mode(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn max_num_components(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (112usize as u32)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_max_num_components(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(112usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (112usize as u32);
    }
    #[inline]
    pub fn max_num_scans(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1920usize as u32)) >>
                                       7u32) as u32)
        }
    }
    #[inline]
    pub fn set_max_num_scans(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1920usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 7u32) & (1920usize as u32);
    }
    #[inline]
    pub fn max_num_huffman_tables(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (14336usize as u32)) >>
                                       11u32) as u32)
        }
    }
    #[inline]
    pub fn set_max_num_huffman_tables(&mut self,
                                      val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(14336usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 11u32) & (14336usize as u32);
    }
    #[inline]
    pub fn max_num_quantization_tables(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (114688usize as u32))
                                       >> 14u32) as u32)
        }
    }
    #[inline]
    pub fn set_max_num_quantization_tables(&mut self,
                                           val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(114688usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (114688usize as u32);
    }
}
#[test]
fn bindgen_test_layout__VAConfigAttribValEncJPEG() {
    assert_eq!(::std::mem::size_of::<_VAConfigAttribValEncJPEG>() , 4usize);
    assert_eq!(::std::mem::align_of::<_VAConfigAttribValEncJPEG>() , 4usize);
}
impl Clone for _VAConfigAttribValEncJPEG {
    fn clone(&self) -> Self { *self }
}
pub type VAConfigAttribValEncJPEG = _VAConfigAttribValEncJPEG;
/** \brief Attribute value for VAConfigAttribEncROI */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAConfigAttribValEncROI {
    pub bits: __BindgenUnionField<_VAConfigAttribValEncROI__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAConfigAttribValEncROI__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__VAConfigAttribValEncROI__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAConfigAttribValEncROI__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAConfigAttribValEncROI__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAConfigAttribValEncROI__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAConfigAttribValEncROI__bindgen_ty_1 {
    #[inline]
    pub fn num_roi_regions(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (255usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_num_roi_regions(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(255usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (255usize as u32);
    }
    #[inline]
    pub fn roi_rc_priority_support(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (256usize as u32)) >>
                                       8u32) as u32)
        }
    }
    #[inline]
    pub fn set_roi_rc_priority_support(&mut self,
                                       val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(256usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 8u32) & (256usize as u32);
    }
    #[inline]
    pub fn reserved(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (4294966784usize as u32)) >> 9u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4294966784usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 9u32) & (4294966784usize as u32);
    }
}
#[test]
fn bindgen_test_layout__VAConfigAttribValEncROI() {
    assert_eq!(::std::mem::size_of::<_VAConfigAttribValEncROI>() , 4usize);
    assert_eq!(::std::mem::align_of::<_VAConfigAttribValEncROI>() , 4usize);
}
impl Clone for _VAConfigAttribValEncROI {
    fn clone(&self) -> Self { *self }
}
pub type VAConfigAttribValEncROI = _VAConfigAttribValEncROI;
extern "C" {
    /** Get maximum number of profiles supported by the implementation */
    pub fn vaMaxNumProfiles(dpy: VADisplay) -> ::std::os::raw::c_int;
}
extern "C" {
    /** Get maximum number of entrypoints supported by the implementation */
    pub fn vaMaxNumEntrypoints(dpy: VADisplay) -> ::std::os::raw::c_int;
}
extern "C" {
    /** Get maximum number of attributs supported by the implementation */
    pub fn vaMaxNumConfigAttributes(dpy: VADisplay) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Query supported profiles 
 * The caller must provide a "profile_list" array that can hold at
 * least vaMaxNumProfile() entries. The actual number of profiles
 * returned in "profile_list" is returned in "num_profile".
 */
    pub fn vaQueryConfigProfiles(dpy: VADisplay, profile_list: *mut VAProfile,
                                 num_profiles: *mut ::std::os::raw::c_int)
     -> VAStatus;
}
extern "C" {
    /**
 * Query supported entrypoints for a given profile 
 * The caller must provide an "entrypoint_list" array that can hold at
 * least vaMaxNumEntrypoints() entries. The actual number of entrypoints 
 * returned in "entrypoint_list" is returned in "num_entrypoints".
 */
    pub fn vaQueryConfigEntrypoints(dpy: VADisplay, profile: VAProfile,
                                    entrypoint_list: *mut VAEntrypoint,
                                    num_entrypoints:
                                        *mut ::std::os::raw::c_int)
     -> VAStatus;
}
extern "C" {
    /**
 * Get attributes for a given profile/entrypoint pair 
 * The caller must provide an "attrib_list" with all attributes to be 
 * retrieved.  Upon return, the attributes in "attrib_list" have been 
 * updated with their value.  Unknown attributes or attributes that are 
 * not supported for the given profile/entrypoint pair will have their 
 * value set to VA_ATTRIB_NOT_SUPPORTED
 */
    pub fn vaGetConfigAttributes(dpy: VADisplay, profile: VAProfile,
                                 entrypoint: VAEntrypoint,
                                 attrib_list: *mut VAConfigAttrib,
                                 num_attribs: ::std::os::raw::c_int)
     -> VAStatus;
}
/** Generic ID type, can be re-typed for specific implementation */
pub type VAGenericID = ::std::os::raw::c_uint;
pub type VAConfigID = VAGenericID;
extern "C" {
    /**
 * Create a configuration for the decode pipeline 
 * it passes in the attribute list that specifies the attributes it cares 
 * about, with the rest taking default values.  
 */
    pub fn vaCreateConfig(dpy: VADisplay, profile: VAProfile,
                          entrypoint: VAEntrypoint,
                          attrib_list: *mut VAConfigAttrib,
                          num_attribs: ::std::os::raw::c_int,
                          config_id: *mut VAConfigID) -> VAStatus;
}
extern "C" {
    /**
 * Free resources associdated with a given config 
 */
    pub fn vaDestroyConfig(dpy: VADisplay, config_id: VAConfigID) -> VAStatus;
}
extern "C" {
    /**
 * Query all attributes for a given configuration 
 * The profile of the configuration is returned in "profile"
 * The entrypoint of the configuration is returned in "entrypoint"
 * The caller must provide an "attrib_list" array that can hold at least 
 * vaMaxNumConfigAttributes() entries. The actual number of attributes 
 * returned in "attrib_list" is returned in "num_attribs"
 */
    pub fn vaQueryConfigAttributes(dpy: VADisplay, config_id: VAConfigID,
                                   profile: *mut VAProfile,
                                   entrypoint: *mut VAEntrypoint,
                                   attrib_list: *mut VAConfigAttrib,
                                   num_attribs: *mut ::std::os::raw::c_int)
     -> VAStatus;
}
/**
 * Contexts and Surfaces
 *
 * Context represents a "virtual" video decode pipeline. Surfaces are render 
 * targets for a given context. The data in the surfaces are not accessible  
 * to the client and the internal data format of the surface is implementatin 
 * specific. 
 *
 * Surfaces will be bound to a context when the context is created. Once
 * a surface is bound to a given context, it can not be used to create  
 * another context. The association is removed when the context is destroyed
 * 
 * Both contexts and surfaces are identified by unique IDs and its
 * implementation specific internals are kept opaque to the clients
 */
pub type VAContextID = VAGenericID;
pub type VASurfaceID = VAGenericID;
pub const VAGenericValueTypeInteger: _bindgen_ty_5 =
    _bindgen_ty_5::VAGenericValueTypeInteger;
pub const VAGenericValueTypeFloat: _bindgen_ty_5 =
    _bindgen_ty_5::VAGenericValueTypeFloat;
pub const VAGenericValueTypePointer: _bindgen_ty_5 =
    _bindgen_ty_5::VAGenericValueTypePointer;
pub const VAGenericValueTypeFunc: _bindgen_ty_5 =
    _bindgen_ty_5::VAGenericValueTypeFunc;
#[repr(u32)]
/** \brief Generic value types. */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_5 {
    VAGenericValueTypeInteger = 1,
    VAGenericValueTypeFloat = 2,
    VAGenericValueTypePointer = 3,
    VAGenericValueTypeFunc = 4,
}
pub use self::_bindgen_ty_5 as VAGenericValueType;
/** \brief Generic function type. */
pub type VAGenericFunc = ::std::option::Option<unsafe extern "C" fn()>;
/** \brief Generic value. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAGenericValue {
    /** \brief Value type. See #VAGenericValueType. */
    pub type_: VAGenericValueType,
    pub value: _VAGenericValue__bindgen_ty_1,
}
/** \brief Value holder. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAGenericValue__bindgen_ty_1 {
    /** \brief 32-bit signed integer. */
    pub i: __BindgenUnionField<::std::os::raw::c_int>,
    /** \brief 32-bit float. */
    pub f: __BindgenUnionField<f32>,
    /** \brief Generic pointer. */
    pub p: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    /** \brief Pointer to function. */
    pub fn_: __BindgenUnionField<VAGenericFunc>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__VAGenericValue__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAGenericValue__bindgen_ty_1>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<_VAGenericValue__bindgen_ty_1>() ,
               8usize);
}
impl Clone for _VAGenericValue__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VAGenericValue() {
    assert_eq!(::std::mem::size_of::<_VAGenericValue>() , 16usize);
    assert_eq!(::std::mem::align_of::<_VAGenericValue>() , 8usize);
}
impl Clone for _VAGenericValue {
    fn clone(&self) -> Self { *self }
}
pub type VAGenericValue = _VAGenericValue;
pub const VASurfaceAttribNone: _bindgen_ty_6 =
    _bindgen_ty_6::VASurfaceAttribNone;
pub const VASurfaceAttribPixelFormat: _bindgen_ty_6 =
    _bindgen_ty_6::VASurfaceAttribPixelFormat;
pub const VASurfaceAttribMinWidth: _bindgen_ty_6 =
    _bindgen_ty_6::VASurfaceAttribMinWidth;
pub const VASurfaceAttribMaxWidth: _bindgen_ty_6 =
    _bindgen_ty_6::VASurfaceAttribMaxWidth;
pub const VASurfaceAttribMinHeight: _bindgen_ty_6 =
    _bindgen_ty_6::VASurfaceAttribMinHeight;
pub const VASurfaceAttribMaxHeight: _bindgen_ty_6 =
    _bindgen_ty_6::VASurfaceAttribMaxHeight;
pub const VASurfaceAttribMemoryType: _bindgen_ty_6 =
    _bindgen_ty_6::VASurfaceAttribMemoryType;
pub const VASurfaceAttribExternalBufferDescriptor: _bindgen_ty_6 =
    _bindgen_ty_6::VASurfaceAttribExternalBufferDescriptor;
pub const VASurfaceAttribUsageHint: _bindgen_ty_6 =
    _bindgen_ty_6::VASurfaceAttribUsageHint;
pub const VASurfaceAttribCount: _bindgen_ty_6 =
    _bindgen_ty_6::VASurfaceAttribCount;
#[repr(u32)]
/** \brief Surface attribute types. */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_6 {
    VASurfaceAttribNone = 0,
    VASurfaceAttribPixelFormat = 1,
    VASurfaceAttribMinWidth = 2,
    VASurfaceAttribMaxWidth = 3,
    VASurfaceAttribMinHeight = 4,
    VASurfaceAttribMaxHeight = 5,
    VASurfaceAttribMemoryType = 6,
    VASurfaceAttribExternalBufferDescriptor = 7,
    VASurfaceAttribUsageHint = 8,
    VASurfaceAttribCount = 9,
}
pub use self::_bindgen_ty_6 as VASurfaceAttribType;
/** \brief Surface attribute. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VASurfaceAttrib {
    /** \brief Type. */
    pub type_: VASurfaceAttribType,
    /** \brief Flags. See "Surface attribute flags". */
    pub flags: ::std::os::raw::c_uint,
    /** \brief Value. See "Surface attribute types" for the expected types. */
    pub value: VAGenericValue,
}
#[test]
fn bindgen_test_layout__VASurfaceAttrib() {
    assert_eq!(::std::mem::size_of::<_VASurfaceAttrib>() , 24usize);
    assert_eq!(::std::mem::align_of::<_VASurfaceAttrib>() , 8usize);
}
impl Clone for _VASurfaceAttrib {
    fn clone(&self) -> Self { *self }
}
pub type VASurfaceAttrib = _VASurfaceAttrib;
/** 
 * \brief VASurfaceAttribExternalBuffers structure for 
 * the VASurfaceAttribExternalBufferDescriptor attribute.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VASurfaceAttribExternalBuffers {
    /** \brief pixel format in fourcc. */
    pub pixel_format: ::std::os::raw::c_uint,
    /** \brief width in pixels. */
    pub width: ::std::os::raw::c_uint,
    /** \brief height in pixels. */
    pub height: ::std::os::raw::c_uint,
    /** \brief total size of the buffer in bytes. */
    pub data_size: ::std::os::raw::c_uint,
    /** \brief number of planes for planar layout */
    pub num_planes: ::std::os::raw::c_uint,
    /** \brief pitch for each plane in bytes */
    pub pitches: [::std::os::raw::c_uint; 4usize],
    /** \brief offset for each plane in bytes */
    pub offsets: [::std::os::raw::c_uint; 4usize],
    /** \brief buffer handles or user pointers */
    pub buffers: *mut ::std::os::raw::c_ulong,
    /** \brief number of elements in the "buffers" array */
    pub num_buffers: ::std::os::raw::c_uint,
    /** \brief flags. See "Surface external buffer descriptor flags". */
    pub flags: ::std::os::raw::c_uint,
    /** \brief reserved for passing private data */
    pub private_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__VASurfaceAttribExternalBuffers() {
    assert_eq!(::std::mem::size_of::<_VASurfaceAttribExternalBuffers>() ,
               80usize);
    assert_eq!(::std::mem::align_of::<_VASurfaceAttribExternalBuffers>() ,
               8usize);
}
impl Clone for _VASurfaceAttribExternalBuffers {
    fn clone(&self) -> Self { *self }
}
pub type VASurfaceAttribExternalBuffers = _VASurfaceAttribExternalBuffers;
extern "C" {
    /**
 * \brief Queries surface attributes for the supplied config.
 *
 * Unlike vaGetSurfaceAttributes(), this function queries for all
 * supported attributes for the supplied VA @config. In particular, if
 * the underlying hardware supports the creation of VA surfaces in
 * various formats, then this function will enumerate all pixel
 * formats that are supported.
 *
 * The \c attrib_list array is allocated by the user and \c
 * num_attribs shall be initialized to the number of allocated
 * elements in that array. Upon successful return, the actual number
 * of attributes will be overwritten into \c num_attribs. Otherwise,
 * \c VA_STATUS_ERROR_MAX_NUM_EXCEEDED is returned and \c num_attribs
 * is adjusted to the number of elements that would be returned if
 * enough space was available.
 *
 * Note: it is perfectly valid to pass NULL to the \c attrib_list
 * argument when vaQuerySurfaceAttributes() is used to determine the
 * actual number of elements that need to be allocated.
 *
 * @param[in] dpy               the VA display
 * @param[in] config            the config identifying a codec or a video
 *     processing pipeline
 * @param[out] attrib_list      the output array of #VASurfaceAttrib elements
 * @param[in,out] num_attribs   the number of elements allocated on
 *      input, the number of elements actually filled in output
 */
    pub fn vaQuerySurfaceAttributes(dpy: VADisplay, config: VAConfigID,
                                    attrib_list: *mut VASurfaceAttrib,
                                    num_attribs: *mut ::std::os::raw::c_uint)
     -> VAStatus;
}
extern "C" {
    /**
 * \brief Creates an array of surfaces
 *
 * Creates an array of surfaces. The optional list of attributes shall
 * be constructed and validated through vaGetSurfaceAttributes() or
 * constructed based based on what the underlying hardware could
 * expose through vaQuerySurfaceAttributes().
 *
 * @param[in] dpy               the VA display
 * @param[in] format            the desired surface format. See \c VA_RT_FORMAT_*
 * @param[in] width             the surface width
 * @param[in] height            the surface height
 * @param[out] surfaces         the array of newly created surfaces
 * @param[in] num_surfaces      the number of surfaces to create
 * @param[in] attrib_list       the list of (optional) attributes, or \c NULL
 * @param[in] num_attribs       the number of attributes supplied in
 *     \c attrib_list, or zero
 */
    pub fn vaCreateSurfaces(dpy: VADisplay, format: ::std::os::raw::c_uint,
                            width: ::std::os::raw::c_uint,
                            height: ::std::os::raw::c_uint,
                            surfaces: *mut VASurfaceID,
                            num_surfaces: ::std::os::raw::c_uint,
                            attrib_list: *mut VASurfaceAttrib,
                            num_attribs: ::std::os::raw::c_uint) -> VAStatus;
}
extern "C" {
    /**
 * vaDestroySurfaces - Destroy resources associated with surfaces. 
 *  Surfaces can only be destroyed after the context associated has been 
 *  destroyed.  
 *  dpy: display
 *  surfaces: array of surfaces to destroy
 *  num_surfaces: number of surfaces in the array to be destroyed.
 */
    pub fn vaDestroySurfaces(dpy: VADisplay, surfaces: *mut VASurfaceID,
                             num_surfaces: ::std::os::raw::c_int) -> VAStatus;
}
extern "C" {
    /**
 * vaCreateContext - Create a context
 *  dpy: display
 *  config_id: configuration for the context
 *  picture_width: coded picture width
 *  picture_height: coded picture height
 *  flag: any combination of the following:
 *    VA_PROGRESSIVE (only progressive frame pictures in the sequence when set)
 *  render_targets: render targets (surfaces) tied to the context
 *  num_render_targets: number of render targets in the above array
 *  context: created context id upon return
 */
    pub fn vaCreateContext(dpy: VADisplay, config_id: VAConfigID,
                           picture_width: ::std::os::raw::c_int,
                           picture_height: ::std::os::raw::c_int,
                           flag: ::std::os::raw::c_int,
                           render_targets: *mut VASurfaceID,
                           num_render_targets: ::std::os::raw::c_int,
                           context: *mut VAContextID) -> VAStatus;
}
extern "C" {
    /**
 * vaDestroyContext - Destroy a context 
 *  dpy: display
 *  context: context to be destroyed
 */
    pub fn vaDestroyContext(dpy: VADisplay, context: VAContextID) -> VAStatus;
}
/**
 * Buffers 
 * Buffers are used to pass various types of data from the
 * client to the server. The server maintains a data store
 * for each buffer created, and the client idenfies a buffer
 * through a unique buffer id assigned by the server.
 */
pub type VABufferID = VAGenericID;
pub const VAPictureParameterBufferType: _bindgen_ty_7 =
    _bindgen_ty_7::VAPictureParameterBufferType;
pub const VAIQMatrixBufferType: _bindgen_ty_7 =
    _bindgen_ty_7::VAIQMatrixBufferType;
pub const VABitPlaneBufferType: _bindgen_ty_7 =
    _bindgen_ty_7::VABitPlaneBufferType;
pub const VASliceGroupMapBufferType: _bindgen_ty_7 =
    _bindgen_ty_7::VASliceGroupMapBufferType;
pub const VASliceParameterBufferType: _bindgen_ty_7 =
    _bindgen_ty_7::VASliceParameterBufferType;
pub const VASliceDataBufferType: _bindgen_ty_7 =
    _bindgen_ty_7::VASliceDataBufferType;
pub const VAMacroblockParameterBufferType: _bindgen_ty_7 =
    _bindgen_ty_7::VAMacroblockParameterBufferType;
pub const VAResidualDataBufferType: _bindgen_ty_7 =
    _bindgen_ty_7::VAResidualDataBufferType;
pub const VADeblockingParameterBufferType: _bindgen_ty_7 =
    _bindgen_ty_7::VADeblockingParameterBufferType;
pub const VAImageBufferType: _bindgen_ty_7 = _bindgen_ty_7::VAImageBufferType;
pub const VAProtectedSliceDataBufferType: _bindgen_ty_7 =
    _bindgen_ty_7::VAProtectedSliceDataBufferType;
pub const VAQMatrixBufferType: _bindgen_ty_7 =
    _bindgen_ty_7::VAQMatrixBufferType;
pub const VAHuffmanTableBufferType: _bindgen_ty_7 =
    _bindgen_ty_7::VAHuffmanTableBufferType;
pub const VAProbabilityBufferType: _bindgen_ty_7 =
    _bindgen_ty_7::VAProbabilityBufferType;
pub const VAEncCodedBufferType: _bindgen_ty_7 =
    _bindgen_ty_7::VAEncCodedBufferType;
pub const VAEncSequenceParameterBufferType: _bindgen_ty_7 =
    _bindgen_ty_7::VAEncSequenceParameterBufferType;
pub const VAEncPictureParameterBufferType: _bindgen_ty_7 =
    _bindgen_ty_7::VAEncPictureParameterBufferType;
pub const VAEncSliceParameterBufferType: _bindgen_ty_7 =
    _bindgen_ty_7::VAEncSliceParameterBufferType;
pub const VAEncPackedHeaderParameterBufferType: _bindgen_ty_7 =
    _bindgen_ty_7::VAEncPackedHeaderParameterBufferType;
pub const VAEncPackedHeaderDataBufferType: _bindgen_ty_7 =
    _bindgen_ty_7::VAEncPackedHeaderDataBufferType;
pub const VAEncMiscParameterBufferType: _bindgen_ty_7 =
    _bindgen_ty_7::VAEncMiscParameterBufferType;
pub const VAEncMacroblockParameterBufferType: _bindgen_ty_7 =
    _bindgen_ty_7::VAEncMacroblockParameterBufferType;
pub const VAEncMacroblockMapBufferType: _bindgen_ty_7 =
    _bindgen_ty_7::VAEncMacroblockMapBufferType;
pub const VAProcPipelineParameterBufferType: _bindgen_ty_7 =
    _bindgen_ty_7::VAProcPipelineParameterBufferType;
pub const VAProcFilterParameterBufferType: _bindgen_ty_7 =
    _bindgen_ty_7::VAProcFilterParameterBufferType;
pub const VABufferTypeMax: _bindgen_ty_7 = _bindgen_ty_7::VABufferTypeMax;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_7 {
    VAPictureParameterBufferType = 0,
    VAIQMatrixBufferType = 1,
    VABitPlaneBufferType = 2,
    VASliceGroupMapBufferType = 3,
    VASliceParameterBufferType = 4,
    VASliceDataBufferType = 5,
    VAMacroblockParameterBufferType = 6,
    VAResidualDataBufferType = 7,
    VADeblockingParameterBufferType = 8,
    VAImageBufferType = 9,
    VAProtectedSliceDataBufferType = 10,
    VAQMatrixBufferType = 11,
    VAHuffmanTableBufferType = 12,
    VAProbabilityBufferType = 13,
    VAEncCodedBufferType = 21,
    VAEncSequenceParameterBufferType = 22,
    VAEncPictureParameterBufferType = 23,
    VAEncSliceParameterBufferType = 24,
    VAEncPackedHeaderParameterBufferType = 25,
    VAEncPackedHeaderDataBufferType = 26,
    VAEncMiscParameterBufferType = 27,
    VAEncMacroblockParameterBufferType = 28,
    VAEncMacroblockMapBufferType = 29,
    VAProcPipelineParameterBufferType = 41,
    VAProcFilterParameterBufferType = 42,
    VABufferTypeMax = 43,
}
pub use self::_bindgen_ty_7 as VABufferType;
pub const VAEncMiscParameterTypeFrameRate: _bindgen_ty_8 =
    _bindgen_ty_8::VAEncMiscParameterTypeFrameRate;
pub const VAEncMiscParameterTypeRateControl: _bindgen_ty_8 =
    _bindgen_ty_8::VAEncMiscParameterTypeRateControl;
pub const VAEncMiscParameterTypeMaxSliceSize: _bindgen_ty_8 =
    _bindgen_ty_8::VAEncMiscParameterTypeMaxSliceSize;
pub const VAEncMiscParameterTypeAIR: _bindgen_ty_8 =
    _bindgen_ty_8::VAEncMiscParameterTypeAIR;
pub const VAEncMiscParameterTypeMaxFrameSize: _bindgen_ty_8 =
    _bindgen_ty_8::VAEncMiscParameterTypeMaxFrameSize;
pub const VAEncMiscParameterTypeHRD: _bindgen_ty_8 =
    _bindgen_ty_8::VAEncMiscParameterTypeHRD;
pub const VAEncMiscParameterTypeQualityLevel: _bindgen_ty_8 =
    _bindgen_ty_8::VAEncMiscParameterTypeQualityLevel;
pub const VAEncMiscParameterTypeSkipFrame: _bindgen_ty_8 =
    _bindgen_ty_8::VAEncMiscParameterTypeSkipFrame;
pub const VAEncMiscParameterTypeROI: _bindgen_ty_8 =
    _bindgen_ty_8::VAEncMiscParameterTypeROI;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_8 {
    VAEncMiscParameterTypeFrameRate = 0,
    VAEncMiscParameterTypeRateControl = 1,
    VAEncMiscParameterTypeMaxSliceSize = 2,
    VAEncMiscParameterTypeAIR = 3,
    VAEncMiscParameterTypeMaxFrameSize = 4,
    VAEncMiscParameterTypeHRD = 5,
    VAEncMiscParameterTypeQualityLevel = 6,
    VAEncMiscParameterTypeSkipFrame = 9,
    VAEncMiscParameterTypeROI = 10,
}
pub use self::_bindgen_ty_8 as VAEncMiscParameterType;
pub const VAEncPackedHeaderSequence: _bindgen_ty_9 =
    _bindgen_ty_9::VAEncPackedHeaderSequence;
pub const VAEncPackedHeaderPicture: _bindgen_ty_9 =
    _bindgen_ty_9::VAEncPackedHeaderPicture;
pub const VAEncPackedHeaderSlice: _bindgen_ty_9 =
    _bindgen_ty_9::VAEncPackedHeaderSlice;
pub const VAEncPackedHeaderRawData: _bindgen_ty_9 =
    _bindgen_ty_9::VAEncPackedHeaderRawData;
pub const VAEncPackedHeaderMiscMask: _bindgen_ty_9 =
    _bindgen_ty_9::VAEncPackedHeaderMiscMask;
#[repr(u32)]
/** \brief Packed header type. */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_9 {
    VAEncPackedHeaderSequence = 1,
    VAEncPackedHeaderPicture = 2,
    VAEncPackedHeaderSlice = 3,
    VAEncPackedHeaderRawData = 4,
    VAEncPackedHeaderMiscMask = 2147483648,
}
pub use self::_bindgen_ty_9 as VAEncPackedHeaderType;
/** \brief Packed header parameter. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncPackedHeaderParameterBuffer {
    /** Type of the packed header buffer. See #VAEncPackedHeaderType. */
    pub type_: ::std::os::raw::c_uint,
    /** \brief Size of the #VAEncPackedHeaderDataBuffer in bits. */
    pub bit_length: ::std::os::raw::c_uint,
    /** \brief Flag: buffer contains start code emulation prevention bytes? */
    pub has_emulation_bytes: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout__VAEncPackedHeaderParameterBuffer() {
    assert_eq!(::std::mem::size_of::<_VAEncPackedHeaderParameterBuffer>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<_VAEncPackedHeaderParameterBuffer>() ,
               4usize);
}
impl Clone for _VAEncPackedHeaderParameterBuffer {
    fn clone(&self) -> Self { *self }
}
pub type VAEncPackedHeaderParameterBuffer = _VAEncPackedHeaderParameterBuffer;
/**
 *  For application, e.g. set a new bitrate
 *    VABufferID buf_id;
 *    VAEncMiscParameterBuffer *misc_param;
 *    VAEncMiscParameterRateControl *misc_rate_ctrl;
 * 
 *    vaCreateBuffer(dpy, context, VAEncMiscParameterBufferType,
 *              sizeof(VAEncMiscParameterBuffer) + sizeof(VAEncMiscParameterRateControl),
 *              1, NULL, &buf_id);
 *
 *    vaMapBuffer(dpy,buf_id,(void **)&misc_param);
 *    misc_param->type = VAEncMiscParameterTypeRateControl;
 *    misc_rate_ctrl= (VAEncMiscParameterRateControl *)misc_param->data;
 *    misc_rate_ctrl->bits_per_second = 6400000;
 *    vaUnmapBuffer(dpy, buf_id);
 *    vaRenderPicture(dpy, context, &buf_id, 1);
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncMiscParameterBuffer {
    pub type_: VAEncMiscParameterType,
    pub data: [::std::os::raw::c_uint; 0usize],
}
#[test]
fn bindgen_test_layout__VAEncMiscParameterBuffer() {
    assert_eq!(::std::mem::size_of::<_VAEncMiscParameterBuffer>() , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncMiscParameterBuffer>() , 4usize);
}
impl Clone for _VAEncMiscParameterBuffer {
    fn clone(&self) -> Self { *self }
}
pub type VAEncMiscParameterBuffer = _VAEncMiscParameterBuffer;
/** \brief Rate control parameters */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncMiscParameterRateControl {
    pub bits_per_second: ::std::os::raw::c_uint,
    pub target_percentage: ::std::os::raw::c_uint,
    pub window_size: ::std::os::raw::c_uint,
    pub initial_qp: ::std::os::raw::c_uint,
    pub min_qp: ::std::os::raw::c_uint,
    pub basic_unit_size: ::std::os::raw::c_uint,
    pub rc_flags: _VAEncMiscParameterRateControl__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncMiscParameterRateControl__bindgen_ty_1 {
    pub bits: __BindgenUnionField<_VAEncMiscParameterRateControl__bindgen_ty_1__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncMiscParameterRateControl__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout__VAEncMiscParameterRateControl__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncMiscParameterRateControl__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncMiscParameterRateControl__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncMiscParameterRateControl__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAEncMiscParameterRateControl__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn reset(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_reset(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn disable_frame_skip(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u8)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_disable_frame_skip(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(2usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 1u32) & (2usize as u8);
    }
    #[inline]
    pub fn disable_bit_stuffing(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4usize as u8)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_disable_bit_stuffing(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 2u32) & (4usize as u8);
    }
    #[inline]
    pub fn mb_rate_control(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (120usize as u8)) >>
                                       3u32) as u32)
        }
    }
    #[inline]
    pub fn set_mb_rate_control(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(120usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 3u32) & (120usize as u8);
    }
}
#[test]
fn bindgen_test_layout__VAEncMiscParameterRateControl__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncMiscParameterRateControl__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncMiscParameterRateControl__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncMiscParameterRateControl__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VAEncMiscParameterRateControl() {
    assert_eq!(::std::mem::size_of::<_VAEncMiscParameterRateControl>() ,
               28usize);
    assert_eq!(::std::mem::align_of::<_VAEncMiscParameterRateControl>() ,
               4usize);
}
impl Clone for _VAEncMiscParameterRateControl {
    fn clone(&self) -> Self { *self }
}
pub type VAEncMiscParameterRateControl = _VAEncMiscParameterRateControl;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncMiscParameterFrameRate {
    pub framerate: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__VAEncMiscParameterFrameRate() {
    assert_eq!(::std::mem::size_of::<_VAEncMiscParameterFrameRate>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<_VAEncMiscParameterFrameRate>() ,
               4usize);
}
impl Clone for _VAEncMiscParameterFrameRate {
    fn clone(&self) -> Self { *self }
}
pub type VAEncMiscParameterFrameRate = _VAEncMiscParameterFrameRate;
/**
 * Allow a maximum slice size to be specified (in bits).
 * The encoder will attempt to make sure that individual slices do not exceed this size
 * Or to signal applicate if the slice size exceed this size, see "status" of VACodedBufferSegment
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncMiscParameterMaxSliceSize {
    pub max_slice_size: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__VAEncMiscParameterMaxSliceSize() {
    assert_eq!(::std::mem::size_of::<_VAEncMiscParameterMaxSliceSize>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<_VAEncMiscParameterMaxSliceSize>() ,
               4usize);
}
impl Clone for _VAEncMiscParameterMaxSliceSize {
    fn clone(&self) -> Self { *self }
}
pub type VAEncMiscParameterMaxSliceSize = _VAEncMiscParameterMaxSliceSize;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncMiscParameterAIR {
    pub air_num_mbs: ::std::os::raw::c_uint,
    pub air_threshold: ::std::os::raw::c_uint,
    pub air_auto: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__VAEncMiscParameterAIR() {
    assert_eq!(::std::mem::size_of::<_VAEncMiscParameterAIR>() , 12usize);
    assert_eq!(::std::mem::align_of::<_VAEncMiscParameterAIR>() , 4usize);
}
impl Clone for _VAEncMiscParameterAIR {
    fn clone(&self) -> Self { *self }
}
pub type VAEncMiscParameterAIR = _VAEncMiscParameterAIR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncMiscParameterHRD {
    pub initial_buffer_fullness: ::std::os::raw::c_uint,
    pub buffer_size: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__VAEncMiscParameterHRD() {
    assert_eq!(::std::mem::size_of::<_VAEncMiscParameterHRD>() , 8usize);
    assert_eq!(::std::mem::align_of::<_VAEncMiscParameterHRD>() , 4usize);
}
impl Clone for _VAEncMiscParameterHRD {
    fn clone(&self) -> Self { *self }
}
pub type VAEncMiscParameterHRD = _VAEncMiscParameterHRD;
/**
 * \brief Defines a maximum frame size (in bits).
 *
 * This misc parameter buffer defines the maximum size of a frame (in
 * bits). The encoder will try to make sure that each frame does not
 * exceed this size. Otherwise, if the frame size exceeds this size,
 * the \c status flag of #VACodedBufferSegment will contain
 * #VA_CODED_BUF_STATUS_FRAME_SIZE_OVERFLOW.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncMiscParameterBufferMaxFrameSize {
    /** \brief Type. Shall be set to #VAEncMiscParameterTypeMaxFrameSize. */
    pub type_: VAEncMiscParameterType,
    /** \brief Maximum size of a frame (in bits). */
    pub max_frame_size: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__VAEncMiscParameterBufferMaxFrameSize() {
    assert_eq!(::std::mem::size_of::<_VAEncMiscParameterBufferMaxFrameSize>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<_VAEncMiscParameterBufferMaxFrameSize>()
               , 4usize);
}
impl Clone for _VAEncMiscParameterBufferMaxFrameSize {
    fn clone(&self) -> Self { *self }
}
pub type VAEncMiscParameterBufferMaxFrameSize =
    _VAEncMiscParameterBufferMaxFrameSize;
/**
 * \brief Encoding quality level.
 *
 * The encoding quality could be set through this structure, if the implementation  
 * supports multiple quality levels. The quality level set through this structure is 
 * persistent over the entire coded sequence, or until a new structure is being sent.
 * The quality level range can be queried through the VAConfigAttribEncQualityRange 
 * attribute. A lower value means higher quality, and a value of 1 represents the highest 
 * quality. The quality level setting is used as a trade-off between quality and speed/power 
 * consumption, with higher quality corresponds to lower speed and higher power consumption. 
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncMiscParameterBufferQualityLevel {
    /** \brief Encoding quality level setting. When set to 0, default quality
     * level is used.
     */
    pub quality_level: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__VAEncMiscParameterBufferQualityLevel() {
    assert_eq!(::std::mem::size_of::<_VAEncMiscParameterBufferQualityLevel>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncMiscParameterBufferQualityLevel>()
               , 4usize);
}
impl Clone for _VAEncMiscParameterBufferQualityLevel {
    fn clone(&self) -> Self { *self }
}
pub type VAEncMiscParameterBufferQualityLevel =
    _VAEncMiscParameterBufferQualityLevel;
/**
 * \brief Encoding skip frame.
 *
 * The application may choose to skip frames externally to the encoder (e.g. drop completely or 
 * code as all skip's). For rate control purposes the encoder will need to know the size and number 
 * of skipped frames.  Skip frame(s) indicated through this structure is applicable only to the 
 * current frame.  It is allowed for the application to still send in packed headers for the driver to 
 * pack, although no frame will be encoded (e.g. for HW to encrypt the frame).  
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncMiscParameterSkipFrame {
    /** \brief Indicates skip frames as below.
      * 0: Encode as normal, no skip.
      * 1: One or more frames were skipped prior to the current frame, encode the current frame as normal.  
      * 2: The current frame is to be skipped, do not encode it but pack/encrypt the packed header contents
      *    (all except VAEncPackedHeaderSlice) which could contain actual frame contents (e.g. pack the frame 
      *    in VAEncPackedHeaderPicture).  */
    pub skip_frame_flag: ::std::os::raw::c_uchar,
    /** \brief The number of frames skipped prior to the current frame.  Valid when skip_frame_flag = 1. */
    pub num_skip_frames: ::std::os::raw::c_uchar,
    /** \brief When skip_frame_flag = 1, the size of the skipped frames in bits.   When skip_frame_flag = 2, 
      * the size of the current skipped frame that is to be packed/encrypted in bits. */
    pub size_skip_frames: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__VAEncMiscParameterSkipFrame() {
    assert_eq!(::std::mem::size_of::<_VAEncMiscParameterSkipFrame>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<_VAEncMiscParameterSkipFrame>() ,
               4usize);
}
impl Clone for _VAEncMiscParameterSkipFrame {
    fn clone(&self) -> Self { *self }
}
pub type VAEncMiscParameterSkipFrame = _VAEncMiscParameterSkipFrame;
/**
 * \brief Encoding region-of-interest (ROI).
 *
 * The encoding ROI can be set through VAEncMiscParameterBufferROI, if the implementation
 * supports ROI input. The ROI set through this structure is applicable only to the
 * current frame or field, so must be sent every frame or field to be applied.  The number of
 * supported ROIs can be queried through the VAConfigAttribEncROI.  The encoder will use the
 * ROI information to adjust the QP values of the MB's that fall within the ROIs.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncROI {
    /** \brief Defines the ROI boundary in pixels, the driver will map it to appropriate
         *  codec coding units.  It is relative to frame coordinates for the frame case and
         *  to field coordinates for the field case. */
    pub roi_rectangle: VARectangle,
    /** \brief When VAConfigAttribRateControl == VA_RC_CQP then roi_value specifes the
	 *  delta QP that will be added on top of the frame level QP.  For other rate control
	 *  modes, roi_value specifies the priority of the ROI region relative to the non-ROI
	 *  region.  It can be positive (more important) or negative (less important) values
         *  and is compared with non-ROI region (taken as value 0).
         *  E.g. ROI region with roi_value -3 is less important than the non-ROI region
	 *  (roi_value implied to be 0) which is less important than ROI region with
	 *  roi_value +2.  For overlapping regions, the roi_value that is first in the ROI
	 *  array will have priority.   */
    pub roi_value: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__VAEncROI() {
    assert_eq!(::std::mem::size_of::<_VAEncROI>() , 10usize);
    assert_eq!(::std::mem::align_of::<_VAEncROI>() , 2usize);
}
impl Clone for _VAEncROI {
    fn clone(&self) -> Self { *self }
}
pub type VAEncROI = _VAEncROI;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncMiscParameterBufferROI {
    /** \brief Number of ROIs being sent.*/
    pub num_roi: ::std::os::raw::c_uint,
    /** \brief Valid when VAConfigAttribRateControl != VA_RC_CQP, then the encoder's
     *  rate control will determine actual delta QPs.  Specifies the max/min allowed delta
     *  QPs. */
    pub max_delta_qp: ::std::os::raw::c_char,
    pub min_delta_qp: ::std::os::raw::c_char,
    /** \brief Pointer to a VAEncROI array with num_roi elements.  It is relative to frame
     *  coordinates for the frame case and to field coordinates for the field case.*/
    pub roi: *mut VAEncROI,
}
#[test]
fn bindgen_test_layout__VAEncMiscParameterBufferROI() {
    assert_eq!(::std::mem::size_of::<_VAEncMiscParameterBufferROI>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<_VAEncMiscParameterBufferROI>() ,
               8usize);
}
impl Clone for _VAEncMiscParameterBufferROI {
    fn clone(&self) -> Self { *self }
}
pub type VAEncMiscParameterBufferROI = _VAEncMiscParameterBufferROI;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VASliceParameterBufferBase {
    pub slice_data_size: ::std::os::raw::c_uint,
    pub slice_data_offset: ::std::os::raw::c_uint,
    pub slice_data_flag: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__VASliceParameterBufferBase() {
    assert_eq!(::std::mem::size_of::<_VASliceParameterBufferBase>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<_VASliceParameterBufferBase>() ,
               4usize);
}
impl Clone for _VASliceParameterBufferBase {
    fn clone(&self) -> Self { *self }
}
pub type VASliceParameterBufferBase = _VASliceParameterBufferBase;
/**********************************
 * JPEG common  data structures
 **********************************/
/**
 * \brief Huffman table for JPEG decoding.
 *
 * This structure holds the complete Huffman tables. This is an
 * aggregation of all Huffman table (DHT) segments maintained by the
 * application. i.e. up to 2 Huffman tables are stored in there for
 * baseline profile.
 *
 * The #load_huffman_table array can be used as a hint to notify the
 * VA driver implementation about which table(s) actually changed
 * since the last submission of this buffer.
 */
#[repr(C)]
pub struct _VAHuffmanTableBufferJPEGBaseline {
    /** \brief Specifies which #huffman_table is valid. */
    pub load_huffman_table: [::std::os::raw::c_uchar; 2usize],
    pub huffman_table: [_VAHuffmanTableBufferJPEGBaseline__bindgen_ty_1; 2usize],
}
/** \brief Huffman tables indexed by table identifier (Th). */
#[repr(C)]
pub struct _VAHuffmanTableBufferJPEGBaseline__bindgen_ty_1 {
    /** @name DC table (up to 12 categories) */
        /**@{*/
        /** \brief Number of Huffman codes of length i + 1 (Li). */
    pub num_dc_codes: [::std::os::raw::c_uchar; 16usize],
    /** \brief Value associated with each Huffman code (Vij). */
    pub dc_values: [::std::os::raw::c_uchar; 12usize],
    /**@}*/
        /** @name AC table (2 special codes + up to 16 * 10 codes) */
        /**@{*/
        /** \brief Number of Huffman codes of length i + 1 (Li). */
    pub num_ac_codes: [::std::os::raw::c_uchar; 16usize],
    /** \brief Value associated with each Huffman code (Vij). */
    pub ac_values: [::std::os::raw::c_uchar; 162usize],
    /** \brief Padding to 4-byte boundaries. Must be set to zero. */
    pub pad: [::std::os::raw::c_uchar; 2usize],
}
#[test]
fn bindgen_test_layout__VAHuffmanTableBufferJPEGBaseline__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAHuffmanTableBufferJPEGBaseline__bindgen_ty_1>()
               , 208usize);
    assert_eq!(::std::mem::align_of::<_VAHuffmanTableBufferJPEGBaseline__bindgen_ty_1>()
               , 1usize);
}
#[test]
fn bindgen_test_layout__VAHuffmanTableBufferJPEGBaseline() {
    assert_eq!(::std::mem::size_of::<_VAHuffmanTableBufferJPEGBaseline>() ,
               418usize);
    assert_eq!(::std::mem::align_of::<_VAHuffmanTableBufferJPEGBaseline>() ,
               1usize);
}
pub type VAHuffmanTableBufferJPEGBaseline = _VAHuffmanTableBufferJPEGBaseline;
/****************************
 * MPEG-2 data structures
 ****************************/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferMPEG2 {
    pub horizontal_size: ::std::os::raw::c_ushort,
    pub vertical_size: ::std::os::raw::c_ushort,
    pub forward_reference_picture: VASurfaceID,
    pub backward_reference_picture: VASurfaceID,
    pub picture_coding_type: ::std::os::raw::c_int,
    pub f_code: ::std::os::raw::c_int,
    pub picture_coding_extension: _VAPictureParameterBufferMPEG2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferMPEG2__bindgen_ty_1 {
    pub bits: __BindgenUnionField<_VAPictureParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAPictureParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn intra_dc_precision(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (3usize as u16)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_intra_dc_precision(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(3usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 0u32) & (3usize as u16);
    }
    #[inline]
    pub fn picture_structure(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (12usize as u16)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_picture_structure(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(12usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 2u32) & (12usize as u16);
    }
    #[inline]
    pub fn top_field_first(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_top_field_first(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn frame_pred_frame_dct(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32usize as u16)) >>
                                       5u32) as u32)
        }
    }
    #[inline]
    pub fn set_frame_pred_frame_dct(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(32usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 5u32) & (32usize as u16);
    }
    #[inline]
    pub fn concealment_motion_vectors(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (64usize as u16)) >>
                                       6u32) as u32)
        }
    }
    #[inline]
    pub fn set_concealment_motion_vectors(&mut self,
                                          val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(64usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 6u32) & (64usize as u16);
    }
    #[inline]
    pub fn q_scale_type(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (128usize as u16)) >>
                                       7u32) as u32)
        }
    }
    #[inline]
    pub fn set_q_scale_type(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(128usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 7u32) & (128usize as u16);
    }
    #[inline]
    pub fn intra_vlc_format(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (256usize as u16)) >>
                                       8u32) as u32)
        }
    }
    #[inline]
    pub fn set_intra_vlc_format(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(256usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 8u32) & (256usize as u16);
    }
    #[inline]
    pub fn alternate_scan(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (512usize as u16)) >>
                                       9u32) as u32)
        }
    }
    #[inline]
    pub fn set_alternate_scan(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(512usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 9u32) & (512usize as u16);
    }
    #[inline]
    pub fn repeat_first_field(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1024usize as u16)) >>
                                       10u32) as u32)
        }
    }
    #[inline]
    pub fn set_repeat_first_field(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1024usize as u16);
        self._bitfield_1 |=
            ((val as u32 as u16) << 10u32) & (1024usize as u16);
    }
    #[inline]
    pub fn progressive_frame(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2048usize as u16)) >>
                                       11u32) as u32)
        }
    }
    #[inline]
    pub fn set_progressive_frame(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(2048usize as u16);
        self._bitfield_1 |=
            ((val as u32 as u16) << 11u32) & (2048usize as u16);
    }
    #[inline]
    pub fn is_first_field(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4096usize as u16)) >>
                                       12u32) as u32)
        }
    }
    #[inline]
    pub fn set_is_first_field(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4096usize as u16);
        self._bitfield_1 |=
            ((val as u32 as u16) << 12u32) & (4096usize as u16);
    }
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferMPEG2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferMPEG2__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferMPEG2__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferMPEG2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferMPEG2() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferMPEG2>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferMPEG2>() ,
               4usize);
}
impl Clone for _VAPictureParameterBufferMPEG2 {
    fn clone(&self) -> Self { *self }
}
pub type VAPictureParameterBufferMPEG2 = _VAPictureParameterBufferMPEG2;
/** MPEG-2 Inverse Quantization Matrix Buffer */
#[repr(C)]
pub struct _VAIQMatrixBufferMPEG2 {
    /** \brief Same as the MPEG-2 bitstream syntax element. */
    pub load_intra_quantiser_matrix: ::std::os::raw::c_int,
    /** \brief Same as the MPEG-2 bitstream syntax element. */
    pub load_non_intra_quantiser_matrix: ::std::os::raw::c_int,
    /** \brief Same as the MPEG-2 bitstream syntax element. */
    pub load_chroma_intra_quantiser_matrix: ::std::os::raw::c_int,
    /** \brief Same as the MPEG-2 bitstream syntax element. */
    pub load_chroma_non_intra_quantiser_matrix: ::std::os::raw::c_int,
    /** \brief Luminance intra matrix, in zig-zag scan order. */
    pub intra_quantiser_matrix: [::std::os::raw::c_uchar; 64usize],
    /** \brief Luminance non-intra matrix, in zig-zag scan order. */
    pub non_intra_quantiser_matrix: [::std::os::raw::c_uchar; 64usize],
    /** \brief Chroma intra matrix, in zig-zag scan order. */
    pub chroma_intra_quantiser_matrix: [::std::os::raw::c_uchar; 64usize],
    /** \brief Chroma non-intra matrix, in zig-zag scan order. */
    pub chroma_non_intra_quantiser_matrix: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout__VAIQMatrixBufferMPEG2() {
    assert_eq!(::std::mem::size_of::<_VAIQMatrixBufferMPEG2>() , 272usize);
    assert_eq!(::std::mem::align_of::<_VAIQMatrixBufferMPEG2>() , 4usize);
}
pub type VAIQMatrixBufferMPEG2 = _VAIQMatrixBufferMPEG2;
/** MPEG-2 Slice Parameter Buffer */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VASliceParameterBufferMPEG2 {
    pub slice_data_size: ::std::os::raw::c_uint,
    pub slice_data_offset: ::std::os::raw::c_uint,
    pub slice_data_flag: ::std::os::raw::c_uint,
    pub macroblock_offset: ::std::os::raw::c_uint,
    pub slice_horizontal_position: ::std::os::raw::c_uint,
    pub slice_vertical_position: ::std::os::raw::c_uint,
    pub quantiser_scale_code: ::std::os::raw::c_int,
    pub intra_slice_flag: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__VASliceParameterBufferMPEG2() {
    assert_eq!(::std::mem::size_of::<_VASliceParameterBufferMPEG2>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<_VASliceParameterBufferMPEG2>() ,
               4usize);
}
impl Clone for _VASliceParameterBufferMPEG2 {
    fn clone(&self) -> Self { *self }
}
pub type VASliceParameterBufferMPEG2 = _VASliceParameterBufferMPEG2;
/** MPEG-2 Macroblock Parameter Buffer */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAMacroblockParameterBufferMPEG2 {
    pub macroblock_address: ::std::os::raw::c_ushort,
    pub macroblock_type: ::std::os::raw::c_uchar,
    pub macroblock_modes: _VAMacroblockParameterBufferMPEG2__bindgen_ty_1,
    pub motion_vertical_field_select: ::std::os::raw::c_uchar,
    pub PMV: [[[::std::os::raw::c_short; 2usize]; 2usize]; 2usize],
    pub coded_block_pattern: ::std::os::raw::c_ushort,
    pub num_skipped_macroblocks: ::std::os::raw::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAMacroblockParameterBufferMPEG2__bindgen_ty_1 {
    pub bits: __BindgenUnionField<_VAMacroblockParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAMacroblockParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout__VAMacroblockParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAMacroblockParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAMacroblockParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAMacroblockParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAMacroblockParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn frame_motion_type(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (3usize as u8)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_frame_motion_type(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(3usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 0u32) & (3usize as u8);
    }
    #[inline]
    pub fn field_motion_type(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (12usize as u8)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_field_motion_type(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(12usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 2u32) & (12usize as u8);
    }
    #[inline]
    pub fn dct_type(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u8)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_dct_type(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(16usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 4u32) & (16usize as u8);
    }
}
#[test]
fn bindgen_test_layout__VAMacroblockParameterBufferMPEG2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAMacroblockParameterBufferMPEG2__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAMacroblockParameterBufferMPEG2__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAMacroblockParameterBufferMPEG2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VAMacroblockParameterBufferMPEG2() {
    assert_eq!(::std::mem::size_of::<_VAMacroblockParameterBufferMPEG2>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<_VAMacroblockParameterBufferMPEG2>() ,
               4usize);
}
impl Clone for _VAMacroblockParameterBufferMPEG2 {
    fn clone(&self) -> Self { *self }
}
pub type VAMacroblockParameterBufferMPEG2 = _VAMacroblockParameterBufferMPEG2;
/****************************
 * MPEG-4 Part 2 data structures
 ****************************/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferMPEG4 {
    pub vop_width: ::std::os::raw::c_ushort,
    pub vop_height: ::std::os::raw::c_ushort,
    pub forward_reference_picture: VASurfaceID,
    pub backward_reference_picture: VASurfaceID,
    pub vol_fields: _VAPictureParameterBufferMPEG4__bindgen_ty_1,
    pub no_of_sprite_warping_points: ::std::os::raw::c_uchar,
    pub sprite_trajectory_du: [::std::os::raw::c_short; 3usize],
    pub sprite_trajectory_dv: [::std::os::raw::c_short; 3usize],
    pub quant_precision: ::std::os::raw::c_uchar,
    pub vop_fields: _VAPictureParameterBufferMPEG4__bindgen_ty_2,
    pub vop_fcode_forward: ::std::os::raw::c_uchar,
    pub vop_fcode_backward: ::std::os::raw::c_uchar,
    pub vop_time_increment_resolution: ::std::os::raw::c_ushort,
    pub num_gobs_in_vop: ::std::os::raw::c_uchar,
    pub num_macroblocks_in_gob: ::std::os::raw::c_uchar,
    pub TRB: ::std::os::raw::c_short,
    pub TRD: ::std::os::raw::c_short,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferMPEG4__bindgen_ty_1 {
    pub bits: __BindgenUnionField<_VAPictureParameterBufferMPEG4__bindgen_ty_1__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferMPEG4__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferMPEG4__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferMPEG4__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferMPEG4__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferMPEG4__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAPictureParameterBufferMPEG4__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn short_video_header(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_short_video_header(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn chroma_format(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (6usize as u16)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_chroma_format(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(6usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 1u32) & (6usize as u16);
    }
    #[inline]
    pub fn interlaced(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8usize as u16)) >>
                                       3u32) as u32)
        }
    }
    #[inline]
    pub fn set_interlaced(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(8usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 3u32) & (8usize as u16);
    }
    #[inline]
    pub fn obmc_disable(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_obmc_disable(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn sprite_enable(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (96usize as u16)) >>
                                       5u32) as u32)
        }
    }
    #[inline]
    pub fn set_sprite_enable(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(96usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 5u32) & (96usize as u16);
    }
    #[inline]
    pub fn sprite_warping_accuracy(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (384usize as u16)) >>
                                       7u32) as u32)
        }
    }
    #[inline]
    pub fn set_sprite_warping_accuracy(&mut self,
                                       val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(384usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 7u32) & (384usize as u16);
    }
    #[inline]
    pub fn quant_type(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (512usize as u16)) >>
                                       9u32) as u32)
        }
    }
    #[inline]
    pub fn set_quant_type(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(512usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 9u32) & (512usize as u16);
    }
    #[inline]
    pub fn quarter_sample(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1024usize as u16)) >>
                                       10u32) as u32)
        }
    }
    #[inline]
    pub fn set_quarter_sample(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1024usize as u16);
        self._bitfield_1 |=
            ((val as u32 as u16) << 10u32) & (1024usize as u16);
    }
    #[inline]
    pub fn data_partitioned(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2048usize as u16)) >>
                                       11u32) as u32)
        }
    }
    #[inline]
    pub fn set_data_partitioned(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(2048usize as u16);
        self._bitfield_1 |=
            ((val as u32 as u16) << 11u32) & (2048usize as u16);
    }
    #[inline]
    pub fn reversible_vlc(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4096usize as u16)) >>
                                       12u32) as u32)
        }
    }
    #[inline]
    pub fn set_reversible_vlc(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4096usize as u16);
        self._bitfield_1 |=
            ((val as u32 as u16) << 12u32) & (4096usize as u16);
    }
    #[inline]
    pub fn resync_marker_disable(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8192usize as u16)) >>
                                       13u32) as u32)
        }
    }
    #[inline]
    pub fn set_resync_marker_disable(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(8192usize as u16);
        self._bitfield_1 |=
            ((val as u32 as u16) << 13u32) & (8192usize as u16);
    }
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferMPEG4__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferMPEG4__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferMPEG4__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferMPEG4__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferMPEG4__bindgen_ty_2 {
    pub bits: __BindgenUnionField<_VAPictureParameterBufferMPEG4__bindgen_ty_2__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferMPEG4__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferMPEG4__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferMPEG4__bindgen_ty_2__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferMPEG4__bindgen_ty_2__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferMPEG4__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAPictureParameterBufferMPEG4__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn vop_coding_type(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (3usize as u16)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_vop_coding_type(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(3usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 0u32) & (3usize as u16);
    }
    #[inline]
    pub fn backward_reference_vop_coding_type(&self)
     -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (12usize as u16)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_backward_reference_vop_coding_type(&mut self,
                                                  val:
                                                      ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(12usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 2u32) & (12usize as u16);
    }
    #[inline]
    pub fn vop_rounding_type(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_vop_rounding_type(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn intra_dc_vlc_thr(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (224usize as u16)) >>
                                       5u32) as u32)
        }
    }
    #[inline]
    pub fn set_intra_dc_vlc_thr(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(224usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 5u32) & (224usize as u16);
    }
    #[inline]
    pub fn top_field_first(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (256usize as u16)) >>
                                       8u32) as u32)
        }
    }
    #[inline]
    pub fn set_top_field_first(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(256usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 8u32) & (256usize as u16);
    }
    #[inline]
    pub fn alternate_vertical_scan_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (512usize as u16)) >>
                                       9u32) as u32)
        }
    }
    #[inline]
    pub fn set_alternate_vertical_scan_flag(&mut self,
                                            val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(512usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 9u32) & (512usize as u16);
    }
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferMPEG4__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferMPEG4__bindgen_ty_2>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferMPEG4__bindgen_ty_2>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferMPEG4__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferMPEG4() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferMPEG4>() ,
               48usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferMPEG4>() ,
               4usize);
}
impl Clone for _VAPictureParameterBufferMPEG4 {
    fn clone(&self) -> Self { *self }
}
pub type VAPictureParameterBufferMPEG4 = _VAPictureParameterBufferMPEG4;
/** MPEG-4 Inverse Quantization Matrix Buffer */
#[repr(C)]
pub struct _VAIQMatrixBufferMPEG4 {
    /** Same as the MPEG-4:2 bitstream syntax element. */
    pub load_intra_quant_mat: ::std::os::raw::c_int,
    /** Same as the MPEG-4:2 bitstream syntax element. */
    pub load_non_intra_quant_mat: ::std::os::raw::c_int,
    /** The matrix for intra blocks, in zig-zag scan order. */
    pub intra_quant_mat: [::std::os::raw::c_uchar; 64usize],
    /** The matrix for non-intra blocks, in zig-zag scan order. */
    pub non_intra_quant_mat: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout__VAIQMatrixBufferMPEG4() {
    assert_eq!(::std::mem::size_of::<_VAIQMatrixBufferMPEG4>() , 136usize);
    assert_eq!(::std::mem::align_of::<_VAIQMatrixBufferMPEG4>() , 4usize);
}
pub type VAIQMatrixBufferMPEG4 = _VAIQMatrixBufferMPEG4;
/** MPEG-4 Slice Parameter Buffer */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VASliceParameterBufferMPEG4 {
    pub slice_data_size: ::std::os::raw::c_uint,
    pub slice_data_offset: ::std::os::raw::c_uint,
    pub slice_data_flag: ::std::os::raw::c_uint,
    pub macroblock_offset: ::std::os::raw::c_uint,
    pub macroblock_number: ::std::os::raw::c_uint,
    pub quant_scale: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__VASliceParameterBufferMPEG4() {
    assert_eq!(::std::mem::size_of::<_VASliceParameterBufferMPEG4>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<_VASliceParameterBufferMPEG4>() ,
               4usize);
}
impl Clone for _VASliceParameterBufferMPEG4 {
    fn clone(&self) -> Self { *self }
}
pub type VASliceParameterBufferMPEG4 = _VASliceParameterBufferMPEG4;
pub const VAMvMode1Mv: _bindgen_ty_10 = _bindgen_ty_10::VAMvMode1Mv;
pub const VAMvMode1MvHalfPel: _bindgen_ty_10 =
    _bindgen_ty_10::VAMvMode1MvHalfPel;
pub const VAMvMode1MvHalfPelBilinear: _bindgen_ty_10 =
    _bindgen_ty_10::VAMvMode1MvHalfPelBilinear;
pub const VAMvModeMixedMv: _bindgen_ty_10 = _bindgen_ty_10::VAMvModeMixedMv;
pub const VAMvModeIntensityCompensation: _bindgen_ty_10 =
    _bindgen_ty_10::VAMvModeIntensityCompensation;
#[repr(u32)]
/**
 VC-1 data structures
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_10 {
    VAMvMode1Mv = 0,
    VAMvMode1MvHalfPel = 1,
    VAMvMode1MvHalfPelBilinear = 2,
    VAMvModeMixedMv = 3,
    VAMvModeIntensityCompensation = 4,
}
pub use self::_bindgen_ty_10 as VAMvModeVC1;
/** VC-1 Picture Parameter Buffer */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferVC1 {
    pub forward_reference_picture: VASurfaceID,
    pub backward_reference_picture: VASurfaceID,
    pub inloop_decoded_picture: VASurfaceID,
    pub sequence_fields: _VAPictureParameterBufferVC1__bindgen_ty_1,
    pub coded_width: ::std::os::raw::c_ushort,
    pub coded_height: ::std::os::raw::c_ushort,
    pub entrypoint_fields: _VAPictureParameterBufferVC1__bindgen_ty_2,
    pub conditional_overlap_flag: ::std::os::raw::c_uchar,
    pub fast_uvmc_flag: ::std::os::raw::c_uchar,
    pub range_mapping_fields: _VAPictureParameterBufferVC1__bindgen_ty_3,
    pub b_picture_fraction: ::std::os::raw::c_uchar,
    pub cbp_table: ::std::os::raw::c_uchar,
    pub mb_mode_table: ::std::os::raw::c_uchar,
    pub range_reduction_frame: ::std::os::raw::c_uchar,
    pub rounding_control: ::std::os::raw::c_uchar,
    pub post_processing: ::std::os::raw::c_uchar,
    pub picture_resolution_index: ::std::os::raw::c_uchar,
    pub luma_scale: ::std::os::raw::c_uchar,
    pub luma_shift: ::std::os::raw::c_uchar,
    pub picture_fields: _VAPictureParameterBufferVC1__bindgen_ty_4,
    pub raw_coding: _VAPictureParameterBufferVC1__bindgen_ty_5,
    pub bitplane_present: _VAPictureParameterBufferVC1__bindgen_ty_6,
    pub reference_fields: _VAPictureParameterBufferVC1__bindgen_ty_7,
    pub mv_fields: _VAPictureParameterBufferVC1__bindgen_ty_8,
    pub pic_quantizer_fields: _VAPictureParameterBufferVC1__bindgen_ty_9,
    pub transform_fields: _VAPictureParameterBufferVC1__bindgen_ty_10,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferVC1__bindgen_ty_1 {
    pub bits: __BindgenUnionField<_VAPictureParameterBufferVC1__bindgen_ty_1__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferVC1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferVC1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferVC1__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferVC1__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferVC1__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAPictureParameterBufferVC1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn pulldown(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_pulldown(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn interlace(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_interlace(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn tfcntrflag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4usize as u16)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_tfcntrflag(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 2u32) & (4usize as u16);
    }
    #[inline]
    pub fn finterpflag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8usize as u16)) >>
                                       3u32) as u32)
        }
    }
    #[inline]
    pub fn set_finterpflag(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(8usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 3u32) & (8usize as u16);
    }
    #[inline]
    pub fn psf(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_psf(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn multires(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32usize as u16)) >>
                                       5u32) as u32)
        }
    }
    #[inline]
    pub fn set_multires(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(32usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 5u32) & (32usize as u16);
    }
    #[inline]
    pub fn overlap(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (64usize as u16)) >>
                                       6u32) as u32)
        }
    }
    #[inline]
    pub fn set_overlap(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(64usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 6u32) & (64usize as u16);
    }
    #[inline]
    pub fn syncmarker(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (128usize as u16)) >>
                                       7u32) as u32)
        }
    }
    #[inline]
    pub fn set_syncmarker(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(128usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 7u32) & (128usize as u16);
    }
    #[inline]
    pub fn rangered(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (256usize as u16)) >>
                                       8u32) as u32)
        }
    }
    #[inline]
    pub fn set_rangered(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(256usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 8u32) & (256usize as u16);
    }
    #[inline]
    pub fn max_b_frames(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (3584usize as u16)) >>
                                       9u32) as u32)
        }
    }
    #[inline]
    pub fn set_max_b_frames(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(3584usize as u16);
        self._bitfield_1 |=
            ((val as u32 as u16) << 9u32) & (3584usize as u16);
    }
    #[inline]
    pub fn profile(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (12288usize as u16)) >>
                                       12u32) as u32)
        }
    }
    #[inline]
    pub fn set_profile(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(12288usize as u16);
        self._bitfield_1 |=
            ((val as u32 as u16) << 12u32) & (12288usize as u16);
    }
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferVC1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferVC1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferVC1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferVC1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferVC1__bindgen_ty_2 {
    pub bits: __BindgenUnionField<_VAPictureParameterBufferVC1__bindgen_ty_2__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferVC1__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferVC1__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferVC1__bindgen_ty_2__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferVC1__bindgen_ty_2__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferVC1__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAPictureParameterBufferVC1__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn broken_link(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_broken_link(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn closed_entry(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u8)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_closed_entry(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(2usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 1u32) & (2usize as u8);
    }
    #[inline]
    pub fn panscan_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4usize as u8)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_panscan_flag(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 2u32) & (4usize as u8);
    }
    #[inline]
    pub fn loopfilter(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8usize as u8)) >>
                                       3u32) as u32)
        }
    }
    #[inline]
    pub fn set_loopfilter(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(8usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 3u32) & (8usize as u8);
    }
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferVC1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferVC1__bindgen_ty_2>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferVC1__bindgen_ty_2>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferVC1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferVC1__bindgen_ty_3 {
    pub bits: __BindgenUnionField<_VAPictureParameterBufferVC1__bindgen_ty_3__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferVC1__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferVC1__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferVC1__bindgen_ty_3__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferVC1__bindgen_ty_3__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferVC1__bindgen_ty_3__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAPictureParameterBufferVC1__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn luma_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_luma_flag(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn luma(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (14usize as u8)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_luma(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(14usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 1u32) & (14usize as u8);
    }
    #[inline]
    pub fn chroma_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u8)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_chroma_flag(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(16usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 4u32) & (16usize as u8);
    }
    #[inline]
    pub fn chroma(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (224usize as u8)) >>
                                       5u32) as u32)
        }
    }
    #[inline]
    pub fn set_chroma(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(224usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 5u32) & (224usize as u8);
    }
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferVC1__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferVC1__bindgen_ty_3>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferVC1__bindgen_ty_3>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferVC1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferVC1__bindgen_ty_4 {
    pub bits: __BindgenUnionField<_VAPictureParameterBufferVC1__bindgen_ty_4__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferVC1__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferVC1__bindgen_ty_4__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferVC1__bindgen_ty_4__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferVC1__bindgen_ty_4__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferVC1__bindgen_ty_4__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAPictureParameterBufferVC1__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn picture_type(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (7usize as u16)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_picture_type(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(7usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 0u32) & (7usize as u16);
    }
    #[inline]
    pub fn frame_coding_mode(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (56usize as u16)) >>
                                       3u32) as u32)
        }
    }
    #[inline]
    pub fn set_frame_coding_mode(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(56usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 3u32) & (56usize as u16);
    }
    #[inline]
    pub fn top_field_first(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (64usize as u16)) >>
                                       6u32) as u32)
        }
    }
    #[inline]
    pub fn set_top_field_first(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(64usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 6u32) & (64usize as u16);
    }
    #[inline]
    pub fn is_first_field(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (128usize as u16)) >>
                                       7u32) as u32)
        }
    }
    #[inline]
    pub fn set_is_first_field(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(128usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 7u32) & (128usize as u16);
    }
    #[inline]
    pub fn intensity_compensation(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (256usize as u16)) >>
                                       8u32) as u32)
        }
    }
    #[inline]
    pub fn set_intensity_compensation(&mut self,
                                      val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(256usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 8u32) & (256usize as u16);
    }
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferVC1__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferVC1__bindgen_ty_4>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferVC1__bindgen_ty_4>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferVC1__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferVC1__bindgen_ty_5 {
    pub flags: __BindgenUnionField<_VAPictureParameterBufferVC1__bindgen_ty_5__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferVC1__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferVC1__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferVC1__bindgen_ty_5__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferVC1__bindgen_ty_5__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferVC1__bindgen_ty_5__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAPictureParameterBufferVC1__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn mv_type_mb(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_mv_type_mb(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn direct_mb(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u8)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_direct_mb(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(2usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 1u32) & (2usize as u8);
    }
    #[inline]
    pub fn skip_mb(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4usize as u8)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_skip_mb(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 2u32) & (4usize as u8);
    }
    #[inline]
    pub fn field_tx(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8usize as u8)) >>
                                       3u32) as u32)
        }
    }
    #[inline]
    pub fn set_field_tx(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(8usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 3u32) & (8usize as u8);
    }
    #[inline]
    pub fn forward_mb(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u8)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_forward_mb(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(16usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 4u32) & (16usize as u8);
    }
    #[inline]
    pub fn ac_pred(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32usize as u8)) >>
                                       5u32) as u32)
        }
    }
    #[inline]
    pub fn set_ac_pred(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(32usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 5u32) & (32usize as u8);
    }
    #[inline]
    pub fn overflags(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (64usize as u8)) >>
                                       6u32) as u32)
        }
    }
    #[inline]
    pub fn set_overflags(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(64usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 6u32) & (64usize as u8);
    }
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferVC1__bindgen_ty_5() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferVC1__bindgen_ty_5>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferVC1__bindgen_ty_5>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferVC1__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferVC1__bindgen_ty_6 {
    pub flags: __BindgenUnionField<_VAPictureParameterBufferVC1__bindgen_ty_6__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferVC1__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferVC1__bindgen_ty_6__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferVC1__bindgen_ty_6__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferVC1__bindgen_ty_6__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferVC1__bindgen_ty_6__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAPictureParameterBufferVC1__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn bp_mv_type_mb(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_bp_mv_type_mb(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn bp_direct_mb(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u8)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_bp_direct_mb(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(2usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 1u32) & (2usize as u8);
    }
    #[inline]
    pub fn bp_skip_mb(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4usize as u8)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_bp_skip_mb(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 2u32) & (4usize as u8);
    }
    #[inline]
    pub fn bp_field_tx(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8usize as u8)) >>
                                       3u32) as u32)
        }
    }
    #[inline]
    pub fn set_bp_field_tx(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(8usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 3u32) & (8usize as u8);
    }
    #[inline]
    pub fn bp_forward_mb(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u8)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_bp_forward_mb(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(16usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 4u32) & (16usize as u8);
    }
    #[inline]
    pub fn bp_ac_pred(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32usize as u8)) >>
                                       5u32) as u32)
        }
    }
    #[inline]
    pub fn set_bp_ac_pred(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(32usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 5u32) & (32usize as u8);
    }
    #[inline]
    pub fn bp_overflags(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (64usize as u8)) >>
                                       6u32) as u32)
        }
    }
    #[inline]
    pub fn set_bp_overflags(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(64usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 6u32) & (64usize as u8);
    }
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferVC1__bindgen_ty_6() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferVC1__bindgen_ty_6>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferVC1__bindgen_ty_6>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferVC1__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferVC1__bindgen_ty_7 {
    pub bits: __BindgenUnionField<_VAPictureParameterBufferVC1__bindgen_ty_7__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferVC1__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferVC1__bindgen_ty_7__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferVC1__bindgen_ty_7__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferVC1__bindgen_ty_7__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferVC1__bindgen_ty_7__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAPictureParameterBufferVC1__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn reference_distance_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_reference_distance_flag(&mut self,
                                       val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn reference_distance(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (62usize as u8)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_reference_distance(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(62usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 1u32) & (62usize as u8);
    }
    #[inline]
    pub fn num_reference_pictures(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (64usize as u8)) >>
                                       6u32) as u32)
        }
    }
    #[inline]
    pub fn set_num_reference_pictures(&mut self,
                                      val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(64usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 6u32) & (64usize as u8);
    }
    #[inline]
    pub fn reference_field_pic_indicator(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (128usize as u8)) >>
                                       7u32) as u32)
        }
    }
    #[inline]
    pub fn set_reference_field_pic_indicator(&mut self,
                                             val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(128usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 7u32) & (128usize as u8);
    }
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferVC1__bindgen_ty_7() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferVC1__bindgen_ty_7>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferVC1__bindgen_ty_7>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferVC1__bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferVC1__bindgen_ty_8 {
    pub bits: __BindgenUnionField<_VAPictureParameterBufferVC1__bindgen_ty_8__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferVC1__bindgen_ty_8__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferVC1__bindgen_ty_8__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferVC1__bindgen_ty_8__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferVC1__bindgen_ty_8__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferVC1__bindgen_ty_8__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAPictureParameterBufferVC1__bindgen_ty_8__bindgen_ty_1 {
    #[inline]
    pub fn mv_mode(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (7usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_mv_mode(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(7usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (7usize as u32);
    }
    #[inline]
    pub fn mv_mode2(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (56usize as u32)) >>
                                       3u32) as u32)
        }
    }
    #[inline]
    pub fn set_mv_mode2(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(56usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (56usize as u32);
    }
    #[inline]
    pub fn mv_table(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (448usize as u32)) >>
                                       6u32) as u32)
        }
    }
    #[inline]
    pub fn set_mv_table(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(448usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (448usize as u32);
    }
    #[inline]
    pub fn two_mv_block_pattern_table(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1536usize as u32)) >>
                                       9u32) as u32)
        }
    }
    #[inline]
    pub fn set_two_mv_block_pattern_table(&mut self,
                                          val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1536usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 9u32) & (1536usize as u32);
    }
    #[inline]
    pub fn four_mv_switch(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2048usize as u32)) >>
                                       11u32) as u32)
        }
    }
    #[inline]
    pub fn set_four_mv_switch(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(2048usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 11u32) & (2048usize as u32);
    }
    #[inline]
    pub fn four_mv_block_pattern_table(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (12288usize as u32)) >>
                                       12u32) as u32)
        }
    }
    #[inline]
    pub fn set_four_mv_block_pattern_table(&mut self,
                                           val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(12288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (12288usize as u32);
    }
    #[inline]
    pub fn extended_mv_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16384usize as u32)) >>
                                       14u32) as u32)
        }
    }
    #[inline]
    pub fn set_extended_mv_flag(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(16384usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (16384usize as u32);
    }
    #[inline]
    pub fn extended_mv_range(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (98304usize as u32)) >>
                                       15u32) as u32)
        }
    }
    #[inline]
    pub fn set_extended_mv_range(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(98304usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 15u32) & (98304usize as u32);
    }
    #[inline]
    pub fn extended_dmv_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (131072usize as u32))
                                       >> 17u32) as u32)
        }
    }
    #[inline]
    pub fn set_extended_dmv_flag(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(131072usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 17u32) & (131072usize as u32);
    }
    #[inline]
    pub fn extended_dmv_range(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (786432usize as u32))
                                       >> 18u32) as u32)
        }
    }
    #[inline]
    pub fn set_extended_dmv_range(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(786432usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 18u32) & (786432usize as u32);
    }
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferVC1__bindgen_ty_8() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferVC1__bindgen_ty_8>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferVC1__bindgen_ty_8>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferVC1__bindgen_ty_8 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferVC1__bindgen_ty_9 {
    pub bits: __BindgenUnionField<_VAPictureParameterBufferVC1__bindgen_ty_9__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferVC1__bindgen_ty_9__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferVC1__bindgen_ty_9__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferVC1__bindgen_ty_9__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferVC1__bindgen_ty_9__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferVC1__bindgen_ty_9__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAPictureParameterBufferVC1__bindgen_ty_9__bindgen_ty_1 {
    #[inline]
    pub fn dquant(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (3usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_dquant(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(3usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (3usize as u32);
    }
    #[inline]
    pub fn quantizer(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (12usize as u32)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_quantizer(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(12usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (12usize as u32);
    }
    #[inline]
    pub fn half_qp(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_half_qp(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn pic_quantizer_scale(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (992usize as u32)) >>
                                       5u32) as u32)
        }
    }
    #[inline]
    pub fn set_pic_quantizer_scale(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(992usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (992usize as u32);
    }
    #[inline]
    pub fn pic_quantizer_type(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1024usize as u32)) >>
                                       10u32) as u32)
        }
    }
    #[inline]
    pub fn set_pic_quantizer_type(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1024usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 10u32) & (1024usize as u32);
    }
    #[inline]
    pub fn dq_frame(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2048usize as u32)) >>
                                       11u32) as u32)
        }
    }
    #[inline]
    pub fn set_dq_frame(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(2048usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 11u32) & (2048usize as u32);
    }
    #[inline]
    pub fn dq_profile(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (12288usize as u32)) >>
                                       12u32) as u32)
        }
    }
    #[inline]
    pub fn set_dq_profile(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(12288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (12288usize as u32);
    }
    #[inline]
    pub fn dq_sb_edge(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (49152usize as u32)) >>
                                       14u32) as u32)
        }
    }
    #[inline]
    pub fn set_dq_sb_edge(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(49152usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (49152usize as u32);
    }
    #[inline]
    pub fn dq_db_edge(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (196608usize as u32))
                                       >> 16u32) as u32)
        }
    }
    #[inline]
    pub fn set_dq_db_edge(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(196608usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (196608usize as u32);
    }
    #[inline]
    pub fn dq_binary_level(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (262144usize as u32))
                                       >> 18u32) as u32)
        }
    }
    #[inline]
    pub fn set_dq_binary_level(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(262144usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 18u32) & (262144usize as u32);
    }
    #[inline]
    pub fn alt_pic_quantizer(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16252928usize as u32))
                                       >> 19u32) as u32)
        }
    }
    #[inline]
    pub fn set_alt_pic_quantizer(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(16252928usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 19u32) & (16252928usize as u32);
    }
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferVC1__bindgen_ty_9() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferVC1__bindgen_ty_9>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferVC1__bindgen_ty_9>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferVC1__bindgen_ty_9 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferVC1__bindgen_ty_10 {
    pub bits: __BindgenUnionField<_VAPictureParameterBufferVC1__bindgen_ty_10__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferVC1__bindgen_ty_10__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferVC1__bindgen_ty_10__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferVC1__bindgen_ty_10__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferVC1__bindgen_ty_10__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferVC1__bindgen_ty_10__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAPictureParameterBufferVC1__bindgen_ty_10__bindgen_ty_1 {
    #[inline]
    pub fn variable_sized_transform_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_variable_sized_transform_flag(&mut self,
                                             val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn mb_level_transform_type_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_mb_level_transform_type_flag(&mut self,
                                            val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn frame_level_transform_type(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (12usize as u16)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_frame_level_transform_type(&mut self,
                                          val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(12usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 2u32) & (12usize as u16);
    }
    #[inline]
    pub fn transform_ac_codingset_idx1(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (48usize as u16)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_transform_ac_codingset_idx1(&mut self,
                                           val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(48usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 4u32) & (48usize as u16);
    }
    #[inline]
    pub fn transform_ac_codingset_idx2(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (192usize as u16)) >>
                                       6u32) as u32)
        }
    }
    #[inline]
    pub fn set_transform_ac_codingset_idx2(&mut self,
                                           val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(192usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 6u32) & (192usize as u16);
    }
    #[inline]
    pub fn intra_transform_dc_table(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (256usize as u16)) >>
                                       8u32) as u32)
        }
    }
    #[inline]
    pub fn set_intra_transform_dc_table(&mut self,
                                        val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(256usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 8u32) & (256usize as u16);
    }
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferVC1__bindgen_ty_10() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferVC1__bindgen_ty_10>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferVC1__bindgen_ty_10>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferVC1__bindgen_ty_10 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferVC1() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferVC1>() ,
               72usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferVC1>() ,
               4usize);
}
impl Clone for _VAPictureParameterBufferVC1 {
    fn clone(&self) -> Self { *self }
}
pub type VAPictureParameterBufferVC1 = _VAPictureParameterBufferVC1;
/** VC-1 Bitplane Buffer
There will be at most three bitplanes coded in any picture header. To send 
the bitplane data more efficiently, each byte is divided in two nibbles, with
each nibble carrying three bitplanes for one macroblock.  The following table
shows the bitplane data arrangement within each nibble based on the picture
type.

Picture Type	Bit3		Bit2		Bit1		Bit0
I or BI				OVERFLAGS	ACPRED		FIELDTX
P				MYTYPEMB	SKIPMB		DIRECTMB
B				FORWARDMB	SKIPMB		DIRECTMB

Within each byte, the lower nibble is for the first MB and the upper nibble is 
for the second MB.  E.g. the lower nibble of the first byte in the bitplane
buffer is for Macroblock #1 and the upper nibble of the first byte is for 
Macroblock #2 in the first row.
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VASliceParameterBufferVC1 {
    pub slice_data_size: ::std::os::raw::c_uint,
    pub slice_data_offset: ::std::os::raw::c_uint,
    pub slice_data_flag: ::std::os::raw::c_uint,
    pub macroblock_offset: ::std::os::raw::c_uint,
    pub slice_vertical_position: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__VASliceParameterBufferVC1() {
    assert_eq!(::std::mem::size_of::<_VASliceParameterBufferVC1>() , 20usize);
    assert_eq!(::std::mem::align_of::<_VASliceParameterBufferVC1>() , 4usize);
}
impl Clone for _VASliceParameterBufferVC1 {
    fn clone(&self) -> Self { *self }
}
pub type VASliceParameterBufferVC1 = _VASliceParameterBufferVC1;
/****************************
 * H.264/AVC data structures
 ****************************/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureH264 {
    pub picture_id: VASurfaceID,
    pub frame_idx: ::std::os::raw::c_uint,
    pub flags: ::std::os::raw::c_uint,
    pub TopFieldOrderCnt: ::std::os::raw::c_int,
    pub BottomFieldOrderCnt: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__VAPictureH264() {
    assert_eq!(::std::mem::size_of::<_VAPictureH264>() , 20usize);
    assert_eq!(::std::mem::align_of::<_VAPictureH264>() , 4usize);
}
impl Clone for _VAPictureH264 {
    fn clone(&self) -> Self { *self }
}
pub type VAPictureH264 = _VAPictureH264;
/** H.264 Picture Parameter Buffer */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferH264 {
    pub CurrPic: VAPictureH264,
    pub ReferenceFrames: [VAPictureH264; 16usize],
    pub picture_width_in_mbs_minus1: ::std::os::raw::c_ushort,
    pub picture_height_in_mbs_minus1: ::std::os::raw::c_ushort,
    pub bit_depth_luma_minus8: ::std::os::raw::c_uchar,
    pub bit_depth_chroma_minus8: ::std::os::raw::c_uchar,
    pub num_ref_frames: ::std::os::raw::c_uchar,
    pub seq_fields: _VAPictureParameterBufferH264__bindgen_ty_1,
    pub num_slice_groups_minus1: ::std::os::raw::c_uchar,
    pub slice_group_map_type: ::std::os::raw::c_uchar,
    pub slice_group_change_rate_minus1: ::std::os::raw::c_ushort,
    pub pic_init_qp_minus26: ::std::os::raw::c_char,
    pub pic_init_qs_minus26: ::std::os::raw::c_char,
    pub chroma_qp_index_offset: ::std::os::raw::c_char,
    pub second_chroma_qp_index_offset: ::std::os::raw::c_char,
    pub pic_fields: _VAPictureParameterBufferH264__bindgen_ty_2,
    pub frame_num: ::std::os::raw::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferH264__bindgen_ty_1 {
    pub bits: __BindgenUnionField<_VAPictureParameterBufferH264__bindgen_ty_1__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferH264__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferH264__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferH264__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferH264__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferH264__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAPictureParameterBufferH264__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn chroma_format_idc(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (3usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_chroma_format_idc(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(3usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (3usize as u32);
    }
    #[inline]
    pub fn residual_colour_transform_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_residual_colour_transform_flag(&mut self,
                                              val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn gaps_in_frame_num_value_allowed_flag(&self)
     -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                       3u32) as u32)
        }
    }
    #[inline]
    pub fn set_gaps_in_frame_num_value_allowed_flag(&mut self,
                                                    val:
                                                        ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn frame_mbs_only_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_frame_mbs_only_flag(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn mb_adaptive_frame_field_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                       5u32) as u32)
        }
    }
    #[inline]
    pub fn set_mb_adaptive_frame_field_flag(&mut self,
                                            val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn direct_8x8_inference_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (64usize as u32)) >>
                                       6u32) as u32)
        }
    }
    #[inline]
    pub fn set_direct_8x8_inference_flag(&mut self,
                                         val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(64usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (64usize as u32);
    }
    #[inline]
    pub fn MinLumaBiPredSize8x8(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (128usize as u32)) >>
                                       7u32) as u32)
        }
    }
    #[inline]
    pub fn set_MinLumaBiPredSize8x8(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(128usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 7u32) & (128usize as u32);
    }
    #[inline]
    pub fn log2_max_frame_num_minus4(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (3840usize as u32)) >>
                                       8u32) as u32)
        }
    }
    #[inline]
    pub fn set_log2_max_frame_num_minus4(&mut self,
                                         val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(3840usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 8u32) & (3840usize as u32);
    }
    #[inline]
    pub fn pic_order_cnt_type(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (12288usize as u32)) >>
                                       12u32) as u32)
        }
    }
    #[inline]
    pub fn set_pic_order_cnt_type(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(12288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (12288usize as u32);
    }
    #[inline]
    pub fn log2_max_pic_order_cnt_lsb_minus4(&self)
     -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (245760usize as u32))
                                       >> 14u32) as u32)
        }
    }
    #[inline]
    pub fn set_log2_max_pic_order_cnt_lsb_minus4(&mut self,
                                                 val:
                                                     ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(245760usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (245760usize as u32);
    }
    #[inline]
    pub fn delta_pic_order_always_zero_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (262144usize as u32))
                                       >> 18u32) as u32)
        }
    }
    #[inline]
    pub fn set_delta_pic_order_always_zero_flag(&mut self,
                                                val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(262144usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 18u32) & (262144usize as u32);
    }
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferH264__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferH264__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferH264__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferH264__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferH264__bindgen_ty_2 {
    pub bits: __BindgenUnionField<_VAPictureParameterBufferH264__bindgen_ty_2__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferH264__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferH264__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferH264__bindgen_ty_2__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferH264__bindgen_ty_2__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferH264__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAPictureParameterBufferH264__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn entropy_coding_mode_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_entropy_coding_mode_flag(&mut self,
                                        val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn weighted_pred_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_weighted_pred_flag(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn weighted_bipred_idc(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (12usize as u16)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_weighted_bipred_idc(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(12usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 2u32) & (12usize as u16);
    }
    #[inline]
    pub fn transform_8x8_mode_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_transform_8x8_mode_flag(&mut self,
                                       val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn field_pic_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32usize as u16)) >>
                                       5u32) as u32)
        }
    }
    #[inline]
    pub fn set_field_pic_flag(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(32usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 5u32) & (32usize as u16);
    }
    #[inline]
    pub fn constrained_intra_pred_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (64usize as u16)) >>
                                       6u32) as u32)
        }
    }
    #[inline]
    pub fn set_constrained_intra_pred_flag(&mut self,
                                           val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(64usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 6u32) & (64usize as u16);
    }
    #[inline]
    pub fn pic_order_present_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (128usize as u16)) >>
                                       7u32) as u32)
        }
    }
    #[inline]
    pub fn set_pic_order_present_flag(&mut self,
                                      val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(128usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 7u32) & (128usize as u16);
    }
    #[inline]
    pub fn deblocking_filter_control_present_flag(&self)
     -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (256usize as u16)) >>
                                       8u32) as u32)
        }
    }
    #[inline]
    pub fn set_deblocking_filter_control_present_flag(&mut self,
                                                      val:
                                                          ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(256usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 8u32) & (256usize as u16);
    }
    #[inline]
    pub fn redundant_pic_cnt_present_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (512usize as u16)) >>
                                       9u32) as u32)
        }
    }
    #[inline]
    pub fn set_redundant_pic_cnt_present_flag(&mut self,
                                              val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(512usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 9u32) & (512usize as u16);
    }
    #[inline]
    pub fn reference_pic_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1024usize as u16)) >>
                                       10u32) as u32)
        }
    }
    #[inline]
    pub fn set_reference_pic_flag(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1024usize as u16);
        self._bitfield_1 |=
            ((val as u32 as u16) << 10u32) & (1024usize as u16);
    }
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferH264__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferH264__bindgen_ty_2>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferH264__bindgen_ty_2>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferH264__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferH264() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferH264>() ,
               368usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferH264>() ,
               4usize);
}
impl Clone for _VAPictureParameterBufferH264 {
    fn clone(&self) -> Self { *self }
}
pub type VAPictureParameterBufferH264 = _VAPictureParameterBufferH264;
/** H.264 Inverse Quantization Matrix Buffer */
#[repr(C)]
#[derive(Copy)]
pub struct _VAIQMatrixBufferH264 {
    /** \brief 4x4 scaling list, in raster scan order. */
    pub ScalingList4x4: [[::std::os::raw::c_uchar; 16usize]; 6usize],
    /** \brief 8x8 scaling list, in raster scan order. */
    pub ScalingList8x8: [[::std::os::raw::c_uchar; 64usize]; 2usize],
}
#[test]
fn bindgen_test_layout__VAIQMatrixBufferH264() {
    assert_eq!(::std::mem::size_of::<_VAIQMatrixBufferH264>() , 224usize);
    assert_eq!(::std::mem::align_of::<_VAIQMatrixBufferH264>() , 1usize);
}
impl Clone for _VAIQMatrixBufferH264 {
    fn clone(&self) -> Self { *self }
}
pub type VAIQMatrixBufferH264 = _VAIQMatrixBufferH264;
/** H.264 Slice Parameter Buffer */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VASliceParameterBufferH264 {
    pub slice_data_size: ::std::os::raw::c_uint,
    /** \brief Byte offset to the NAL Header Unit for this slice. */
    pub slice_data_offset: ::std::os::raw::c_uint,
    pub slice_data_flag: ::std::os::raw::c_uint,
    /**
     * \brief Bit offset from NAL Header Unit to the begining of slice_data().
     *
     * This bit offset is relative to and includes the NAL unit byte
     * and represents the number of bits parsed in the slice_header()
     * after the removal of any emulation prevention bytes in
     * there. However, the slice data buffer passed to the hardware is
     * the original bitstream, thus including any emulation prevention
     * bytes.
     */
    pub slice_data_bit_offset: ::std::os::raw::c_ushort,
    pub first_mb_in_slice: ::std::os::raw::c_ushort,
    pub slice_type: ::std::os::raw::c_uchar,
    pub direct_spatial_mv_pred_flag: ::std::os::raw::c_uchar,
    pub num_ref_idx_l0_active_minus1: ::std::os::raw::c_uchar,
    pub num_ref_idx_l1_active_minus1: ::std::os::raw::c_uchar,
    pub cabac_init_idc: ::std::os::raw::c_uchar,
    pub slice_qp_delta: ::std::os::raw::c_char,
    pub disable_deblocking_filter_idc: ::std::os::raw::c_uchar,
    pub slice_alpha_c0_offset_div2: ::std::os::raw::c_char,
    pub slice_beta_offset_div2: ::std::os::raw::c_char,
    pub RefPicList0: [VAPictureH264; 32usize],
    pub RefPicList1: [VAPictureH264; 32usize],
    pub luma_log2_weight_denom: ::std::os::raw::c_uchar,
    pub chroma_log2_weight_denom: ::std::os::raw::c_uchar,
    pub luma_weight_l0_flag: ::std::os::raw::c_uchar,
    pub luma_weight_l0: [::std::os::raw::c_short; 32usize],
    pub luma_offset_l0: [::std::os::raw::c_short; 32usize],
    pub chroma_weight_l0_flag: ::std::os::raw::c_uchar,
    pub chroma_weight_l0: [[::std::os::raw::c_short; 2usize]; 32usize],
    pub chroma_offset_l0: [[::std::os::raw::c_short; 2usize]; 32usize],
    pub luma_weight_l1_flag: ::std::os::raw::c_uchar,
    pub luma_weight_l1: [::std::os::raw::c_short; 32usize],
    pub luma_offset_l1: [::std::os::raw::c_short; 32usize],
    pub chroma_weight_l1_flag: ::std::os::raw::c_uchar,
    pub chroma_weight_l1: [[::std::os::raw::c_short; 2usize]; 32usize],
    pub chroma_offset_l1: [[::std::os::raw::c_short; 2usize]; 32usize],
}
#[test]
fn bindgen_test_layout__VASliceParameterBufferH264() {
    assert_eq!(::std::mem::size_of::<_VASliceParameterBufferH264>() ,
               2088usize);
    assert_eq!(::std::mem::align_of::<_VASliceParameterBufferH264>() ,
               4usize);
}
impl Clone for _VASliceParameterBufferH264 {
    fn clone(&self) -> Self { *self }
}
pub type VASliceParameterBufferH264 = _VASliceParameterBufferH264;
pub const VAEncPictureTypeIntra: _bindgen_ty_11 =
    _bindgen_ty_11::VAEncPictureTypeIntra;
pub const VAEncPictureTypePredictive: _bindgen_ty_11 =
    _bindgen_ty_11::VAEncPictureTypePredictive;
pub const VAEncPictureTypeBidirectional: _bindgen_ty_11 =
    _bindgen_ty_11::VAEncPictureTypeBidirectional;
#[repr(u32)]
/****************************
 * Common encode data structures 
 ****************************/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_11 {
    VAEncPictureTypeIntra = 0,
    VAEncPictureTypePredictive = 1,
    VAEncPictureTypeBidirectional = 2,
}
pub use self::_bindgen_ty_11 as VAEncPictureType;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSliceParameterBuffer {
    pub start_row_number: ::std::os::raw::c_uint,
    pub slice_height: ::std::os::raw::c_uint,
    pub slice_flags: _VAEncSliceParameterBuffer__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSliceParameterBuffer__bindgen_ty_1 {
    pub bits: __BindgenUnionField<_VAEncSliceParameterBuffer__bindgen_ty_1__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSliceParameterBuffer__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout__VAEncSliceParameterBuffer__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncSliceParameterBuffer__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncSliceParameterBuffer__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncSliceParameterBuffer__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAEncSliceParameterBuffer__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn is_intra(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_is_intra(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn disable_deblocking_filter_idc(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (6usize as u8)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_disable_deblocking_filter_idc(&mut self,
                                             val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(6usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 1u32) & (6usize as u8);
    }
    #[inline]
    pub fn uses_long_term_ref(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8usize as u8)) >>
                                       3u32) as u32)
        }
    }
    #[inline]
    pub fn set_uses_long_term_ref(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(8usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 3u32) & (8usize as u8);
    }
    #[inline]
    pub fn is_long_term_ref(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u8)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_is_long_term_ref(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(16usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 4u32) & (16usize as u8);
    }
}
#[test]
fn bindgen_test_layout__VAEncSliceParameterBuffer__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncSliceParameterBuffer__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncSliceParameterBuffer__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncSliceParameterBuffer__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VAEncSliceParameterBuffer() {
    assert_eq!(::std::mem::size_of::<_VAEncSliceParameterBuffer>() , 12usize);
    assert_eq!(::std::mem::align_of::<_VAEncSliceParameterBuffer>() , 4usize);
}
impl Clone for _VAEncSliceParameterBuffer {
    fn clone(&self) -> Self { *self }
}
pub type VAEncSliceParameterBuffer = _VAEncSliceParameterBuffer;
/****************************
 * H.263 specific encode data structures
 ****************************/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSequenceParameterBufferH263 {
    pub intra_period: ::std::os::raw::c_uint,
    pub bits_per_second: ::std::os::raw::c_uint,
    pub frame_rate: ::std::os::raw::c_uint,
    pub initial_qp: ::std::os::raw::c_uint,
    pub min_qp: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__VAEncSequenceParameterBufferH263() {
    assert_eq!(::std::mem::size_of::<_VAEncSequenceParameterBufferH263>() ,
               20usize);
    assert_eq!(::std::mem::align_of::<_VAEncSequenceParameterBufferH263>() ,
               4usize);
}
impl Clone for _VAEncSequenceParameterBufferH263 {
    fn clone(&self) -> Self { *self }
}
pub type VAEncSequenceParameterBufferH263 = _VAEncSequenceParameterBufferH263;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncPictureParameterBufferH263 {
    pub reference_picture: VASurfaceID,
    pub reconstructed_picture: VASurfaceID,
    pub coded_buf: VABufferID,
    pub picture_width: ::std::os::raw::c_ushort,
    pub picture_height: ::std::os::raw::c_ushort,
    pub picture_type: VAEncPictureType,
}
#[test]
fn bindgen_test_layout__VAEncPictureParameterBufferH263() {
    assert_eq!(::std::mem::size_of::<_VAEncPictureParameterBufferH263>() ,
               20usize);
    assert_eq!(::std::mem::align_of::<_VAEncPictureParameterBufferH263>() ,
               4usize);
}
impl Clone for _VAEncPictureParameterBufferH263 {
    fn clone(&self) -> Self { *self }
}
pub type VAEncPictureParameterBufferH263 = _VAEncPictureParameterBufferH263;
/****************************
 * MPEG-4 specific encode data structures
 ****************************/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSequenceParameterBufferMPEG4 {
    pub profile_and_level_indication: ::std::os::raw::c_uchar,
    pub intra_period: ::std::os::raw::c_uint,
    pub video_object_layer_width: ::std::os::raw::c_uint,
    pub video_object_layer_height: ::std::os::raw::c_uint,
    pub vop_time_increment_resolution: ::std::os::raw::c_uint,
    pub fixed_vop_rate: ::std::os::raw::c_uint,
    pub fixed_vop_time_increment: ::std::os::raw::c_uint,
    pub bits_per_second: ::std::os::raw::c_uint,
    pub frame_rate: ::std::os::raw::c_uint,
    pub initial_qp: ::std::os::raw::c_uint,
    pub min_qp: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__VAEncSequenceParameterBufferMPEG4() {
    assert_eq!(::std::mem::size_of::<_VAEncSequenceParameterBufferMPEG4>() ,
               44usize);
    assert_eq!(::std::mem::align_of::<_VAEncSequenceParameterBufferMPEG4>() ,
               4usize);
}
impl Clone for _VAEncSequenceParameterBufferMPEG4 {
    fn clone(&self) -> Self { *self }
}
pub type VAEncSequenceParameterBufferMPEG4 =
    _VAEncSequenceParameterBufferMPEG4;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncPictureParameterBufferMPEG4 {
    pub reference_picture: VASurfaceID,
    pub reconstructed_picture: VASurfaceID,
    pub coded_buf: VABufferID,
    pub picture_width: ::std::os::raw::c_ushort,
    pub picture_height: ::std::os::raw::c_ushort,
    pub modulo_time_base: ::std::os::raw::c_uint,
    pub vop_time_increment: ::std::os::raw::c_uint,
    pub picture_type: VAEncPictureType,
}
#[test]
fn bindgen_test_layout__VAEncPictureParameterBufferMPEG4() {
    assert_eq!(::std::mem::size_of::<_VAEncPictureParameterBufferMPEG4>() ,
               28usize);
    assert_eq!(::std::mem::align_of::<_VAEncPictureParameterBufferMPEG4>() ,
               4usize);
}
impl Clone for _VAEncPictureParameterBufferMPEG4 {
    fn clone(&self) -> Self { *self }
}
pub type VAEncPictureParameterBufferMPEG4 = _VAEncPictureParameterBufferMPEG4;
extern "C" {
    /**
 * Creates a buffer for "num_elements" elements of "size" bytes and 
 * initalize with "data".
 * if "data" is null, then the contents of the buffer data store
 * are undefined.
 * Basically there are two ways to get buffer data to the server side. One is 
 * to call vaCreateBuffer() with a non-null "data", which results the data being
 * copied to the data store on the server side.  A different method that 
 * eliminates this copy is to pass null as "data" when calling vaCreateBuffer(),
 * and then use vaMapBuffer() to map the data store from the server side to the
 * client address space for access.
 *  Note: image buffers are created by the library, not the client. Please see 
 *        vaCreateImage on how image buffers are managed.
 */
    pub fn vaCreateBuffer(dpy: VADisplay, context: VAContextID,
                          type_: VABufferType, size: ::std::os::raw::c_uint,
                          num_elements: ::std::os::raw::c_uint,
                          data: *mut ::std::os::raw::c_void,
                          buf_id: *mut VABufferID) -> VAStatus;
}
extern "C" {
    /**
 * Convey to the server how many valid elements are in the buffer. 
 * e.g. if multiple slice parameters are being held in a single buffer,
 * this will communicate to the server the number of slice parameters
 * that are valid in the buffer.
 */
    pub fn vaBufferSetNumElements(dpy: VADisplay, buf_id: VABufferID,
                                  num_elements: ::std::os::raw::c_uint)
     -> VAStatus;
}
/**
 * \brief Coded buffer segment.
 *
 * #VACodedBufferSegment is an element of a linked list describing
 * some information on the coded buffer. The coded buffer segment
 * could contain either a single NAL unit, or more than one NAL unit. 
 * It is recommended (but not required) to return a single NAL unit 
 * in a coded buffer segment, and the implementation should set the 
 * VA_CODED_BUF_STATUS_SINGLE_NALU status flag if that is the case.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VACodedBufferSegment {
    /**
     * \brief Size of the data buffer in this segment (in bytes).
     */
    pub size: ::std::os::raw::c_uint,
    /** \brief Bit offset into the data buffer where the video data starts. */
    pub bit_offset: ::std::os::raw::c_uint,
    /** \brief Status set by the driver. See \c VA_CODED_BUF_STATUS_*. */
    pub status: ::std::os::raw::c_uint,
    /** \brief Reserved for future use. */
    pub reserved: ::std::os::raw::c_uint,
    /** \brief Pointer to the start of the data buffer. */
    pub buf: *mut ::std::os::raw::c_void,
    /**
     * \brief Pointer to the next #VACodedBufferSegment element,
     * or \c NULL if there is none.
     */
    pub next: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__VACodedBufferSegment() {
    assert_eq!(::std::mem::size_of::<_VACodedBufferSegment>() , 32usize);
    assert_eq!(::std::mem::align_of::<_VACodedBufferSegment>() , 8usize);
}
impl Clone for _VACodedBufferSegment {
    fn clone(&self) -> Self { *self }
}
pub type VACodedBufferSegment = _VACodedBufferSegment;
extern "C" {
    /**
 * Map data store of the buffer into the client's address space
 * vaCreateBuffer() needs to be called with "data" set to NULL before
 * calling vaMapBuffer()
 *
 * if buffer type is VAEncCodedBufferType, pbuf points to link-list of
 * VACodedBufferSegment, and the list is terminated if "next" is NULL
 */
    pub fn vaMapBuffer(dpy: VADisplay, buf_id: VABufferID,
                       pbuf: *mut *mut ::std::os::raw::c_void) -> VAStatus;
}
extern "C" {
    /**
 * After client making changes to a mapped data store, it needs to
 * "Unmap" it to let the server know that the data is ready to be
 * consumed by the server
 */
    pub fn vaUnmapBuffer(dpy: VADisplay, buf_id: VABufferID) -> VAStatus;
}
extern "C" {
    /**
 * After this call, the buffer is deleted and this buffer_id is no longer valid
 * Only call this if the buffer is not going to be passed to vaRenderBuffer
 */
    pub fn vaDestroyBuffer(dpy: VADisplay, buffer_id: VABufferID) -> VAStatus;
}
/** \brief VA buffer information */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_12 {
    /** \brief Buffer handle */
    pub handle: usize,
    /** \brief Buffer type (See \ref VABufferType). */
    pub type_: u32,
    /**
     * \brief Buffer memory type (See \ref VASurfaceAttribMemoryType).
     *
     * On input to vaAcquireBufferHandle(), this field can serve as a hint
     * to specify the set of memory types the caller is interested in.
     * On successful return from vaAcquireBufferHandle(), the field is
     * updated with the best matching memory type.
     */
    pub mem_type: u32,
    /** \brief Size of the underlying buffer. */
    pub mem_size: usize,
}
#[test]
fn bindgen_test_layout__bindgen_ty_12() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_12>() , 24usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_12>() , 8usize);
}
impl Clone for _bindgen_ty_12 {
    fn clone(&self) -> Self { *self }
}
pub type VABufferInfo = _bindgen_ty_12;
extern "C" {
    /**
 * \brief Acquires buffer handle for external API usage
 *
 * Locks the VA buffer object \ref buf_id for external API usage like
 * EGL or OpenCL (OCL). This function is a synchronization point. This
 * means that any pending operation is guaranteed to be completed
 * prior to returning from the function.
 *
 * If the referenced VA buffer object is the backing store of a VA
 * surface, then this function acts as if vaSyncSurface() on the
 * parent surface was called first.
 *
 * The \ref VABufferInfo argument shall be zero'ed on input. On
 * successful output, the data structure is filled in with all the
 * necessary buffer level implementation details like handle, type,
 * memory type and memory size.
 *
 * Note: the external API implementation, or the application, can
 * express the memory types it is interested in by filling in the \ref
 * mem_type field accordingly. On successful output, the memory type
 * that fits best the request and that was used is updated in the \ref
 * VABufferInfo data structure. If none of the supplied memory types
 * is supported, then a \ref VA_STATUS_ERROR_UNSUPPORTED_MEMORY_TYPE
 * error is returned.
 *
 * The \ref VABufferInfo data is valid until vaReleaseBufferHandle()
 * is called. Besides, no additional operation is allowed on any of
 * the buffer parent object until vaReleaseBufferHandle() is called.
 * e.g. decoding into a VA surface backed with the supplied VA buffer
 * object \ref buf_id would fail with a \ref VA_STATUS_ERROR_SURFACE_BUSY
 * error.
 *
 * Possible errors:
 * - \ref VA_STATUS_ERROR_UNIMPLEMENTED: the VA driver implementation
 *   does not support this interface
 * - \ref VA_STATUS_ERROR_INVALID_DISPLAY: an invalid display was supplied
 * - \ref VA_STATUS_ERROR_INVALID_BUFFER: an invalid buffer was supplied
 * - \ref VA_STATUS_ERROR_UNSUPPORTED_BUFFERTYPE: the implementation
 *   does not support exporting buffers of the specified type
 * - \ref VA_STATUS_ERROR_UNSUPPORTED_MEMORY_TYPE: none of the requested
 *   memory types in \ref VABufferInfo.mem_type was supported
 *
 * @param[in] dpy               the VA display
 * @param[in] buf_id            the VA buffer
 * @param[in,out] buf_info      the associated VA buffer information
 * @return VA_STATUS_SUCCESS if successful
 */
    pub fn vaAcquireBufferHandle(dpy: VADisplay, buf_id: VABufferID,
                                 buf_info: *mut VABufferInfo) -> VAStatus;
}
extern "C" {
    /**
 * \brief Releases buffer after usage from external API
 *
 * Unlocks the VA buffer object \ref buf_id from external API usage like
 * EGL or OpenCL (OCL). This function is a synchronization point. This
 * means that any pending operation is guaranteed to be completed
 * prior to returning from the function.
 *
 * The \ref VABufferInfo argument shall point to the original data
 * structure that was obtained from vaAcquireBufferHandle(), unaltered.
 * This is necessary so that the VA driver implementation could
 * deallocate any resources that were needed.
 *
 * In any case, returning from this function invalidates any contents
 * in \ref VABufferInfo. i.e. the underlyng buffer handle is no longer
 * valid. Therefore, VA driver implementations are free to reset this
 * data structure to safe defaults.
 *
 * Possible errors:
 * - \ref VA_STATUS_ERROR_UNIMPLEMENTED: the VA driver implementation
 *   does not support this interface
 * - \ref VA_STATUS_ERROR_INVALID_DISPLAY: an invalid display was supplied
 * - \ref VA_STATUS_ERROR_INVALID_BUFFER: an invalid buffer was supplied
 * - \ref VA_STATUS_ERROR_UNSUPPORTED_BUFFERTYPE: the implementation
 *   does not support exporting buffers of the specified type
 *
 * @param[in] dpy               the VA display
 * @param[in] buf_id            the VA buffer
 * @return VA_STATUS_SUCCESS if successful
 */
    pub fn vaReleaseBufferHandle(dpy: VADisplay, buf_id: VABufferID)
     -> VAStatus;
}
extern "C" {
    /**
 * Get ready to decode a picture to a target surface
 */
    pub fn vaBeginPicture(dpy: VADisplay, context: VAContextID,
                          render_target: VASurfaceID) -> VAStatus;
}
extern "C" {
    /**
 * Send decode buffers to the server.
 * Buffers are automatically destroyed afterwards
 */
    pub fn vaRenderPicture(dpy: VADisplay, context: VAContextID,
                           buffers: *mut VABufferID,
                           num_buffers: ::std::os::raw::c_int) -> VAStatus;
}
extern "C" {
    /**
 * Make the end of rendering for a picture. 
 * The server should start processing all pending operations for this 
 * surface. This call is non-blocking. The client can start another 
 * Begin/Render/End sequence on a different render target.
 */
    pub fn vaEndPicture(dpy: VADisplay, context: VAContextID) -> VAStatus;
}
extern "C" {
    /**
 * This function blocks until all pending operations on the render target
 * have been completed.  Upon return it is safe to use the render target for a 
 * different picture. 
 */
    pub fn vaSyncSurface(dpy: VADisplay, render_target: VASurfaceID)
     -> VAStatus;
}
pub const VASurfaceRendering: _bindgen_ty_13 =
    _bindgen_ty_13::VASurfaceRendering;
pub const VASurfaceDisplaying: _bindgen_ty_13 =
    _bindgen_ty_13::VASurfaceDisplaying;
pub const VASurfaceReady: _bindgen_ty_13 = _bindgen_ty_13::VASurfaceReady;
pub const VASurfaceSkipped: _bindgen_ty_13 = _bindgen_ty_13::VASurfaceSkipped;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_13 {
    VASurfaceRendering = 1,
    VASurfaceDisplaying = 2,
    VASurfaceReady = 4,
    VASurfaceSkipped = 8,
}
pub use self::_bindgen_ty_13 as VASurfaceStatus;
extern "C" {
    /**
 * Find out any pending ops on the render target 
 */
    pub fn vaQuerySurfaceStatus(dpy: VADisplay, render_target: VASurfaceID,
                                status: *mut VASurfaceStatus) -> VAStatus;
}
pub const VADecodeSliceMissing: _bindgen_ty_14 =
    _bindgen_ty_14::VADecodeSliceMissing;
pub const VADecodeMBError: _bindgen_ty_14 = _bindgen_ty_14::VADecodeMBError;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_14 { VADecodeSliceMissing = 0, VADecodeMBError = 1, }
pub use self::_bindgen_ty_14 as VADecodeErrorType;
/**
 * Client calls vaQuerySurfaceError with VA_STATUS_ERROR_DECODING_ERROR, server side returns
 * an array of structure VASurfaceDecodeMBErrors, and the array is terminated by setting status=-1
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VASurfaceDecodeMBErrors {
    pub status: ::std::os::raw::c_int,
    pub start_mb: ::std::os::raw::c_uint,
    pub end_mb: ::std::os::raw::c_uint,
    pub decode_error_type: VADecodeErrorType,
}
#[test]
fn bindgen_test_layout__VASurfaceDecodeMBErrors() {
    assert_eq!(::std::mem::size_of::<_VASurfaceDecodeMBErrors>() , 16usize);
    assert_eq!(::std::mem::align_of::<_VASurfaceDecodeMBErrors>() , 4usize);
}
impl Clone for _VASurfaceDecodeMBErrors {
    fn clone(&self) -> Self { *self }
}
pub type VASurfaceDecodeMBErrors = _VASurfaceDecodeMBErrors;
extern "C" {
    /**
 * After the application gets VA_STATUS_ERROR_DECODING_ERROR after calling vaSyncSurface(),
 * it can call vaQuerySurfaceError to find out further details on the particular error.
 * VA_STATUS_ERROR_DECODING_ERROR should be passed in as "error_status",
 * upon the return, error_info will point to an array of _VASurfaceDecodeMBErrors structure,
 * which is allocated and filled by libVA with detailed information on the missing or error macroblocks.
 * The array is terminated if "status==-1" is detected.
 */
    pub fn vaQuerySurfaceError(dpy: VADisplay, surface: VASurfaceID,
                               error_status: VAStatus,
                               error_info: *mut *mut ::std::os::raw::c_void)
     -> VAStatus;
}
#[repr(C)]
#[derive(Debug, Copy, Default)]
pub struct _VAImageFormat {
    pub fourcc: ::std::os::raw::c_uint,
    pub byte_order: ::std::os::raw::c_uint,
    pub bits_per_pixel: ::std::os::raw::c_uint,
    pub depth: ::std::os::raw::c_uint,
    pub red_mask: ::std::os::raw::c_uint,
    pub green_mask: ::std::os::raw::c_uint,
    pub blue_mask: ::std::os::raw::c_uint,
    pub alpha_mask: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__VAImageFormat() {
    assert_eq!(::std::mem::size_of::<_VAImageFormat>() , 32usize);
    assert_eq!(::std::mem::align_of::<_VAImageFormat>() , 4usize);
}
impl Clone for _VAImageFormat {
    fn clone(&self) -> Self { *self }
}
pub type VAImageFormat = _VAImageFormat;
pub type VAImageID = VAGenericID;
#[repr(C)]
#[derive(Debug, Copy, Default)]
pub struct _VAImage {
    pub image_id: VAImageID,
    pub format: VAImageFormat,
    pub buf: VABufferID,
    pub width: ::std::os::raw::c_ushort,
    pub height: ::std::os::raw::c_ushort,
    pub data_size: ::std::os::raw::c_uint,
    pub num_planes: ::std::os::raw::c_uint,
    pub pitches: [::std::os::raw::c_uint; 3usize],
    pub offsets: [::std::os::raw::c_uint; 3usize],
    pub num_palette_entries: ::std::os::raw::c_int,
    pub entry_bytes: ::std::os::raw::c_int,
    pub component_order: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout__VAImage() {
    assert_eq!(::std::mem::size_of::<_VAImage>() , 88usize);
    assert_eq!(::std::mem::align_of::<_VAImage>() , 4usize);
}
impl Clone for _VAImage {
    fn clone(&self) -> Self { *self }
}
pub type VAImage = _VAImage;
extern "C" {
    /** Get maximum number of image formats supported by the implementation */
    pub fn vaMaxNumImageFormats(dpy: VADisplay) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Query supported image formats 
 * The caller must provide a "format_list" array that can hold at
 * least vaMaxNumImageFormats() entries. The actual number of formats
 * returned in "format_list" is returned in "num_formats".
 */
    pub fn vaQueryImageFormats(dpy: VADisplay,
                               format_list: *mut VAImageFormat,
                               num_formats: *mut ::std::os::raw::c_int)
     -> VAStatus;
}
extern "C" {
    /**
 * Create a VAImage structure
 * The width and height fields returned in the VAImage structure may get 
 * enlarged for some YUV formats. Upon return from this function, 
 * image->buf has been created and proper storage allocated by the library. 
 * The client can access the image through the Map/Unmap calls.
 */
    pub fn vaCreateImage(dpy: VADisplay, format: *mut VAImageFormat,
                         width: ::std::os::raw::c_int,
                         height: ::std::os::raw::c_int, image: *mut VAImage)
     -> VAStatus;
}
extern "C" {
    /**
 * Should call DestroyImage before destroying the surface it is bound to
 */
    pub fn vaDestroyImage(dpy: VADisplay, image: VAImageID) -> VAStatus;
}
extern "C" {
    pub fn vaSetImagePalette(dpy: VADisplay, image: VAImageID,
                             palette: *mut ::std::os::raw::c_uchar)
     -> VAStatus;
}
extern "C" {
    /**
 * Retrive surface data into a VAImage
 * Image must be in a format supported by the implementation
 */
    pub fn vaGetImage(dpy: VADisplay, surface: VASurfaceID,
                      x: ::std::os::raw::c_int, y: ::std::os::raw::c_int,
                      width: ::std::os::raw::c_uint,
                      height: ::std::os::raw::c_uint, image: VAImageID)
     -> VAStatus;
}
extern "C" {
    /**
 * Copy data from a VAImage to a surface
 * Image must be in a format supported by the implementation
 * Returns a VA_STATUS_ERROR_SURFACE_BUSY if the surface
 * shouldn't be rendered into when this is called
 */
    pub fn vaPutImage(dpy: VADisplay, surface: VASurfaceID, image: VAImageID,
                      src_x: ::std::os::raw::c_int,
                      src_y: ::std::os::raw::c_int,
                      src_width: ::std::os::raw::c_uint,
                      src_height: ::std::os::raw::c_uint,
                      dest_x: ::std::os::raw::c_int,
                      dest_y: ::std::os::raw::c_int,
                      dest_width: ::std::os::raw::c_uint,
                      dest_height: ::std::os::raw::c_uint) -> VAStatus;
}
extern "C" {
    /**
 * Derive an VAImage from an existing surface.
 * This interface will derive a VAImage and corresponding image buffer from
 * an existing VA Surface. The image buffer can then be mapped/unmapped for
 * direct CPU access. This operation is only possible on implementations with
 * direct rendering capabilities and internal surface formats that can be
 * represented with a VAImage. When the operation is not possible this interface
 * will return VA_STATUS_ERROR_OPERATION_FAILED. Clients should then fall back
 * to using vaCreateImage + vaPutImage to accomplish the same task in an
 * indirect manner.
 *
 * Implementations should only return success when the resulting image buffer
 * would be useable with vaMap/Unmap.
 *
 * When directly accessing a surface special care must be taken to insure
 * proper synchronization with the graphics hardware. Clients should call
 * vaQuerySurfaceStatus to insure that a surface is not the target of concurrent
 * rendering or currently being displayed by an overlay.
 *
 * Additionally nothing about the contents of a surface should be assumed
 * following a vaPutSurface. Implementations are free to modify the surface for
 * scaling or subpicture blending within a call to vaPutImage.
 *
 * Calls to vaPutImage or vaGetImage using the same surface from which the image
 * has been derived will return VA_STATUS_ERROR_SURFACE_BUSY. vaPutImage or
 * vaGetImage with other surfaces is supported.
 *
 * An image created with vaDeriveImage should be freed with vaDestroyImage. The
 * image and image buffer structures will be destroyed; however, the underlying
 * surface will remain unchanged until freed with vaDestroySurfaces.
 */
    pub fn vaDeriveImage(dpy: VADisplay, surface: VASurfaceID,
                         image: *mut VAImage) -> VAStatus;
}
/**
 * Subpictures 
 * Subpicture is a special type of image that can be blended 
 * with a surface during vaPutSurface(). Subpicture can be used to render
 * DVD sub-titles or closed captioning text etc.  
 */
pub type VASubpictureID = VAGenericID;
extern "C" {
    /** Get maximum number of subpicture formats supported by the implementation */
    pub fn vaMaxNumSubpictureFormats(dpy: VADisplay) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Query supported subpicture formats 
 * The caller must provide a "format_list" array that can hold at
 * least vaMaxNumSubpictureFormats() entries. The flags arrary holds the flag 
 * for each format to indicate additional capabilities for that format. The actual 
 * number of formats returned in "format_list" is returned in "num_formats".
 *  flags: returned value to indicate addtional capabilities
 *         VA_SUBPICTURE_CHROMA_KEYING - supports chroma-keying
 *         VA_SUBPICTURE_GLOBAL_ALPHA - supports global alpha
 * 	   VA_SUBPICTURE_DESTINATION_IS_SCREEN_COORD - supports unscaled screen relative subpictures for On Screen Display
 */
    pub fn vaQuerySubpictureFormats(dpy: VADisplay,
                                    format_list: *mut VAImageFormat,
                                    flags: *mut ::std::os::raw::c_uint,
                                    num_formats: *mut ::std::os::raw::c_uint)
     -> VAStatus;
}
extern "C" {
    /**
 * Subpictures are created with an image associated. 
 */
    pub fn vaCreateSubpicture(dpy: VADisplay, image: VAImageID,
                              subpicture: *mut VASubpictureID) -> VAStatus;
}
extern "C" {
    /**
 * Destroy the subpicture before destroying the image it is assocated to
 */
    pub fn vaDestroySubpicture(dpy: VADisplay, subpicture: VASubpictureID)
     -> VAStatus;
}
extern "C" {
    /**
 * Bind an image to the subpicture. This image will now be associated with 
 * the subpicture instead of the one at creation.
 */
    pub fn vaSetSubpictureImage(dpy: VADisplay, subpicture: VASubpictureID,
                                image: VAImageID) -> VAStatus;
}
extern "C" {
    /**
 * If chromakey is enabled, then the area where the source value falls within
 * the chromakey [min, max] range is transparent
 * The chromakey component format is the following:
 *  For RGB: [0:7] Red [8:15] Blue [16:23] Green   
 *  For YUV: [0:7] V [8:15] U [16:23] Y
 * The chromakey mask can be used to mask out certain components for chromakey
 * comparision
 */
    pub fn vaSetSubpictureChromakey(dpy: VADisplay,
                                    subpicture: VASubpictureID,
                                    chromakey_min: ::std::os::raw::c_uint,
                                    chromakey_max: ::std::os::raw::c_uint,
                                    chromakey_mask: ::std::os::raw::c_uint)
     -> VAStatus;
}
extern "C" {
    /**
 * Global alpha value is between 0 and 1. A value of 1 means fully opaque and 
 * a value of 0 means fully transparent. If per-pixel alpha is also specified then
 * the overall alpha is per-pixel alpha multiplied by the global alpha
 */
    pub fn vaSetSubpictureGlobalAlpha(dpy: VADisplay,
                                      subpicture: VASubpictureID,
                                      global_alpha: f32) -> VAStatus;
}
extern "C" {
    /**
 * vaAssociateSubpicture associates the subpicture with target_surfaces.
 * It defines the region mapping between the subpicture and the target  
 * surfaces through source and destination rectangles (with the same width and height).
 * Both will be displayed at the next call to vaPutSurface.  Additional
 * associations before the call to vaPutSurface simply overrides the association.
 */
    pub fn vaAssociateSubpicture(dpy: VADisplay, subpicture: VASubpictureID,
                                 target_surfaces: *mut VASurfaceID,
                                 num_surfaces: ::std::os::raw::c_int,
                                 src_x: ::std::os::raw::c_short,
                                 src_y: ::std::os::raw::c_short,
                                 src_width: ::std::os::raw::c_ushort,
                                 src_height: ::std::os::raw::c_ushort,
                                 dest_x: ::std::os::raw::c_short,
                                 dest_y: ::std::os::raw::c_short,
                                 dest_width: ::std::os::raw::c_ushort,
                                 dest_height: ::std::os::raw::c_ushort,
                                 flags: ::std::os::raw::c_uint) -> VAStatus;
}
extern "C" {
    /**
 * vaDeassociateSubpicture removes the association of the subpicture with target_surfaces.
 */
    pub fn vaDeassociateSubpicture(dpy: VADisplay, subpicture: VASubpictureID,
                                   target_surfaces: *mut VASurfaceID,
                                   num_surfaces: ::std::os::raw::c_int)
     -> VAStatus;
}
pub const VADISPLAYATTRIB_BLE_OFF: _bindgen_ty_15 =
    _bindgen_ty_15::VADISPLAYATTRIB_BLE_OFF;
pub const VADISPLAYATTRIB_BLE_LOW: _bindgen_ty_15 =
    _bindgen_ty_15::VADISPLAYATTRIB_BLE_LOW;
pub const VADISPLAYATTRIB_BLE_MEDIUM: _bindgen_ty_15 =
    _bindgen_ty_15::VADISPLAYATTRIB_BLE_MEDIUM;
pub const VADISPLAYATTRIB_BLE_HIGH: _bindgen_ty_15 =
    _bindgen_ty_15::VADISPLAYATTRIB_BLE_HIGH;
pub const VADISPLAYATTRIB_BLE_NONE: _bindgen_ty_15 =
    _bindgen_ty_15::VADISPLAYATTRIB_BLE_NONE;
#[repr(u32)]
/**
 * Display attributes
 * Display attributes are used to control things such as contrast, hue, saturation,
 * brightness etc. in the rendering process.  The application can query what
 * attributes are supported by the driver, and then set the appropriate attributes
 * before calling vaPutSurface()
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_15 {
    VADISPLAYATTRIB_BLE_OFF = 0,
    VADISPLAYATTRIB_BLE_LOW = 1,
    VADISPLAYATTRIB_BLE_MEDIUM = 2,
    VADISPLAYATTRIB_BLE_HIGH = 3,
    VADISPLAYATTRIB_BLE_NONE = 4,
}
pub use self::_bindgen_ty_15 as VADisplayAttribBLEMode;
pub const VADisplayAttribBrightness: _bindgen_ty_16 =
    _bindgen_ty_16::VADisplayAttribBrightness;
pub const VADisplayAttribContrast: _bindgen_ty_16 =
    _bindgen_ty_16::VADisplayAttribContrast;
pub const VADisplayAttribHue: _bindgen_ty_16 =
    _bindgen_ty_16::VADisplayAttribHue;
pub const VADisplayAttribSaturation: _bindgen_ty_16 =
    _bindgen_ty_16::VADisplayAttribSaturation;
pub const VADisplayAttribBackgroundColor: _bindgen_ty_16 =
    _bindgen_ty_16::VADisplayAttribBackgroundColor;
pub const VADisplayAttribDirectSurface: _bindgen_ty_16 =
    _bindgen_ty_16::VADisplayAttribDirectSurface;
pub const VADisplayAttribRotation: _bindgen_ty_16 =
    _bindgen_ty_16::VADisplayAttribRotation;
pub const VADisplayAttribOutofLoopDeblock: _bindgen_ty_16 =
    _bindgen_ty_16::VADisplayAttribOutofLoopDeblock;
pub const VADisplayAttribBLEBlackMode: _bindgen_ty_16 =
    _bindgen_ty_16::VADisplayAttribBLEBlackMode;
pub const VADisplayAttribBLEWhiteMode: _bindgen_ty_16 =
    _bindgen_ty_16::VADisplayAttribBLEWhiteMode;
pub const VADisplayAttribBlueStretch: _bindgen_ty_16 =
    _bindgen_ty_16::VADisplayAttribBlueStretch;
pub const VADisplayAttribSkinColorCorrection: _bindgen_ty_16 =
    _bindgen_ty_16::VADisplayAttribSkinColorCorrection;
pub const VADisplayAttribCSCMatrix: _bindgen_ty_16 =
    _bindgen_ty_16::VADisplayAttribCSCMatrix;
pub const VADisplayAttribBlendColor: _bindgen_ty_16 =
    _bindgen_ty_16::VADisplayAttribBlendColor;
pub const VADisplayAttribOverlayAutoPaintColorKey: _bindgen_ty_16 =
    _bindgen_ty_16::VADisplayAttribOverlayAutoPaintColorKey;
pub const VADisplayAttribOverlayColorKey: _bindgen_ty_16 =
    _bindgen_ty_16::VADisplayAttribOverlayColorKey;
pub const VADisplayAttribRenderMode: _bindgen_ty_16 =
    _bindgen_ty_16::VADisplayAttribRenderMode;
pub const VADisplayAttribRenderDevice: _bindgen_ty_16 =
    _bindgen_ty_16::VADisplayAttribRenderDevice;
pub const VADisplayAttribRenderRect: _bindgen_ty_16 =
    _bindgen_ty_16::VADisplayAttribRenderRect;
#[repr(u32)]
/** Currently defined display attribute types */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_16 {
    VADisplayAttribBrightness = 0,
    VADisplayAttribContrast = 1,
    VADisplayAttribHue = 2,
    VADisplayAttribSaturation = 3,
    VADisplayAttribBackgroundColor = 4,
    VADisplayAttribDirectSurface = 5,
    VADisplayAttribRotation = 6,
    VADisplayAttribOutofLoopDeblock = 7,
    VADisplayAttribBLEBlackMode = 8,
    VADisplayAttribBLEWhiteMode = 9,
    VADisplayAttribBlueStretch = 10,
    VADisplayAttribSkinColorCorrection = 11,
    VADisplayAttribCSCMatrix = 12,
    VADisplayAttribBlendColor = 13,
    VADisplayAttribOverlayAutoPaintColorKey = 14,
    VADisplayAttribOverlayColorKey = 15,
    VADisplayAttribRenderMode = 16,
    VADisplayAttribRenderDevice = 17,
    VADisplayAttribRenderRect = 18,
}
pub use self::_bindgen_ty_16 as VADisplayAttribType;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VADisplayAttribute {
    pub type_: VADisplayAttribType,
    pub min_value: ::std::os::raw::c_int,
    pub max_value: ::std::os::raw::c_int,
    pub value: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__VADisplayAttribute() {
    assert_eq!(::std::mem::size_of::<_VADisplayAttribute>() , 20usize);
    assert_eq!(::std::mem::align_of::<_VADisplayAttribute>() , 4usize);
}
impl Clone for _VADisplayAttribute {
    fn clone(&self) -> Self { *self }
}
pub type VADisplayAttribute = _VADisplayAttribute;
extern "C" {
    /** Get maximum number of display attributs supported by the implementation */
    pub fn vaMaxNumDisplayAttributes(dpy: VADisplay) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Query display attributes 
 * The caller must provide a "attr_list" array that can hold at
 * least vaMaxNumDisplayAttributes() entries. The actual number of attributes
 * returned in "attr_list" is returned in "num_attributes".
 */
    pub fn vaQueryDisplayAttributes(dpy: VADisplay,
                                    attr_list: *mut VADisplayAttribute,
                                    num_attributes:
                                        *mut ::std::os::raw::c_int)
     -> VAStatus;
}
extern "C" {
    /**
 * Get display attributes 
 * This function returns the current attribute values in "attr_list".
 * Only attributes returned with VA_DISPLAY_ATTRIB_GETTABLE set in the "flags" field
 * from vaQueryDisplayAttributes() can have their values retrieved.  
 */
    pub fn vaGetDisplayAttributes(dpy: VADisplay,
                                  attr_list: *mut VADisplayAttribute,
                                  num_attributes: ::std::os::raw::c_int)
     -> VAStatus;
}
extern "C" {
    /**
 * Set display attributes 
 * Only attributes returned with VA_DISPLAY_ATTRIB_SETTABLE set in the "flags" field
 * from vaQueryDisplayAttributes() can be set.  If the attribute is not settable or 
 * the value is out of range, the function returns VA_STATUS_ERROR_ATTR_NOT_SUPPORTED
 */
    pub fn vaSetDisplayAttributes(dpy: VADisplay,
                                  attr_list: *mut VADisplayAttribute,
                                  num_attributes: ::std::os::raw::c_int)
     -> VAStatus;
}
/****************************
 * HEVC data structures
 ****************************/
/** 
 * \brief Description of picture properties of those in DPB surfaces.
 *
 * If only progressive scan is supported, each surface contains one whole 
 * frame picture.
 * Otherwise, each surface contains two fields of whole picture.
 * In this case, two entries of ReferenceFrames[] may share same picture_id
 * value.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureHEVC {
    /** \brief reconstructed picture buffer surface index 
     * invalid when taking value VA_INVALID_SURFACE.
     */
    pub picture_id: VASurfaceID,
    /** \brief picture order count. 
     * in HEVC, POCs for top and bottom fields of same picture should
     * take different values.
     */
    pub pic_order_cnt: i32,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout__VAPictureHEVC() {
    assert_eq!(::std::mem::size_of::<_VAPictureHEVC>() , 12usize);
    assert_eq!(::std::mem::align_of::<_VAPictureHEVC>() , 4usize);
}
impl Clone for _VAPictureHEVC {
    fn clone(&self) -> Self { *self }
}
pub type VAPictureHEVC = _VAPictureHEVC;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferHEVC {
    pub CurrPic: VAPictureHEVC,
    pub ReferenceFrames: [VAPictureHEVC; 15usize],
    pub pic_width_in_luma_samples: u16,
    pub pic_height_in_luma_samples: u16,
    pub pic_fields: _VAPictureParameterBufferHEVC__bindgen_ty_1,
    pub sps_max_dec_pic_buffering_minus1: u8,
    pub bit_depth_luma_minus8: u8,
    pub bit_depth_chroma_minus8: u8,
    pub pcm_sample_bit_depth_luma_minus1: u8,
    pub pcm_sample_bit_depth_chroma_minus1: u8,
    pub log2_min_luma_coding_block_size_minus3: u8,
    pub log2_diff_max_min_luma_coding_block_size: u8,
    pub log2_min_transform_block_size_minus2: u8,
    pub log2_diff_max_min_transform_block_size: u8,
    pub log2_min_pcm_luma_coding_block_size_minus3: u8,
    pub log2_diff_max_min_pcm_luma_coding_block_size: u8,
    pub max_transform_hierarchy_depth_intra: u8,
    pub max_transform_hierarchy_depth_inter: u8,
    pub init_qp_minus26: i8,
    pub diff_cu_qp_delta_depth: u8,
    pub pps_cb_qp_offset: i8,
    pub pps_cr_qp_offset: i8,
    pub log2_parallel_merge_level_minus2: u8,
    pub num_tile_columns_minus1: u8,
    pub num_tile_rows_minus1: u8,
    pub column_width_minus1: [u16; 19usize],
    pub row_height_minus1: [u16; 21usize],
    pub slice_parsing_fields: _VAPictureParameterBufferHEVC__bindgen_ty_2,
    pub log2_max_pic_order_cnt_lsb_minus4: u8,
    pub num_short_term_ref_pic_sets: u8,
    pub num_long_term_ref_pic_sps: u8,
    pub num_ref_idx_l0_default_active_minus1: u8,
    pub num_ref_idx_l1_default_active_minus1: u8,
    pub pps_beta_offset_div2: i8,
    pub pps_tc_offset_div2: i8,
    pub num_extra_slice_header_bits: u8,
    pub st_rps_bits: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferHEVC__bindgen_ty_1 {
    pub bits: __BindgenUnionField<_VAPictureParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1>,
    pub value: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAPictureParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn chroma_format_idc(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (3usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_chroma_format_idc(&mut self, val: u32) {
        self._bitfield_1 &= !(3usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (3usize as u32);
    }
    #[inline]
    pub fn separate_colour_plane_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_separate_colour_plane_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn pcm_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                       3u32) as u32)
        }
    }
    #[inline]
    pub fn set_pcm_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn scaling_list_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_scaling_list_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn transform_skip_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                       5u32) as u32)
        }
    }
    #[inline]
    pub fn set_transform_skip_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn amp_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (64usize as u32)) >>
                                       6u32) as u32)
        }
    }
    #[inline]
    pub fn set_amp_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(64usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (64usize as u32);
    }
    #[inline]
    pub fn strong_intra_smoothing_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (128usize as u32)) >>
                                       7u32) as u32)
        }
    }
    #[inline]
    pub fn set_strong_intra_smoothing_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(128usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 7u32) & (128usize as u32);
    }
    #[inline]
    pub fn sign_data_hiding_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (256usize as u32)) >>
                                       8u32) as u32)
        }
    }
    #[inline]
    pub fn set_sign_data_hiding_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(256usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 8u32) & (256usize as u32);
    }
    #[inline]
    pub fn constrained_intra_pred_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (512usize as u32)) >>
                                       9u32) as u32)
        }
    }
    #[inline]
    pub fn set_constrained_intra_pred_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(512usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 9u32) & (512usize as u32);
    }
    #[inline]
    pub fn cu_qp_delta_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1024usize as u32)) >>
                                       10u32) as u32)
        }
    }
    #[inline]
    pub fn set_cu_qp_delta_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(1024usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 10u32) & (1024usize as u32);
    }
    #[inline]
    pub fn weighted_pred_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2048usize as u32)) >>
                                       11u32) as u32)
        }
    }
    #[inline]
    pub fn set_weighted_pred_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(2048usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 11u32) & (2048usize as u32);
    }
    #[inline]
    pub fn weighted_bipred_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4096usize as u32)) >>
                                       12u32) as u32)
        }
    }
    #[inline]
    pub fn set_weighted_bipred_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(4096usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (4096usize as u32);
    }
    #[inline]
    pub fn transquant_bypass_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8192usize as u32)) >>
                                       13u32) as u32)
        }
    }
    #[inline]
    pub fn set_transquant_bypass_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(8192usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 13u32) & (8192usize as u32);
    }
    #[inline]
    pub fn tiles_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16384usize as u32)) >>
                                       14u32) as u32)
        }
    }
    #[inline]
    pub fn set_tiles_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(16384usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (16384usize as u32);
    }
    #[inline]
    pub fn entropy_coding_sync_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32768usize as u32)) >>
                                       15u32) as u32)
        }
    }
    #[inline]
    pub fn set_entropy_coding_sync_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(32768usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 15u32) & (32768usize as u32);
    }
    #[inline]
    pub fn pps_loop_filter_across_slices_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (65536usize as u32)) >>
                                       16u32) as u32)
        }
    }
    #[inline]
    pub fn set_pps_loop_filter_across_slices_enabled_flag(&mut self,
                                                          val: u32) {
        self._bitfield_1 &= !(65536usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (65536usize as u32);
    }
    #[inline]
    pub fn loop_filter_across_tiles_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (131072usize as u32))
                                       >> 17u32) as u32)
        }
    }
    #[inline]
    pub fn set_loop_filter_across_tiles_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(131072usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 17u32) & (131072usize as u32);
    }
    #[inline]
    pub fn pcm_loop_filter_disabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (262144usize as u32))
                                       >> 18u32) as u32)
        }
    }
    #[inline]
    pub fn set_pcm_loop_filter_disabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(262144usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 18u32) & (262144usize as u32);
    }
    #[inline]
    pub fn NoPicReorderingFlag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (524288usize as u32))
                                       >> 19u32) as u32)
        }
    }
    #[inline]
    pub fn set_NoPicReorderingFlag(&mut self, val: u32) {
        self._bitfield_1 &= !(524288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 19u32) & (524288usize as u32);
    }
    #[inline]
    pub fn NoBiPredFlag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1048576usize as u32))
                                       >> 20u32) as u32)
        }
    }
    #[inline]
    pub fn set_NoBiPredFlag(&mut self, val: u32) {
        self._bitfield_1 &= !(1048576usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 20u32) & (1048576usize as u32);
    }
    #[inline]
    pub fn ReservedBits(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (4292870144usize as u32)) >> 21u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_ReservedBits(&mut self, val: u32) {
        self._bitfield_1 &= !(4292870144usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 21u32) & (4292870144usize as u32);
    }
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferHEVC__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferHEVC__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferHEVC__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferHEVC__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferHEVC__bindgen_ty_2 {
    pub bits: __BindgenUnionField<_VAPictureParameterBufferHEVC__bindgen_ty_2__bindgen_ty_1>,
    pub value: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferHEVC__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferHEVC__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferHEVC__bindgen_ty_2__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferHEVC__bindgen_ty_2__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferHEVC__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAPictureParameterBufferHEVC__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn lists_modification_present_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_lists_modification_present_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn long_term_ref_pics_present_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_long_term_ref_pics_present_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn sps_temporal_mvp_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_sps_temporal_mvp_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn cabac_init_present_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                       3u32) as u32)
        }
    }
    #[inline]
    pub fn set_cabac_init_present_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn output_flag_present_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_output_flag_present_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn dependent_slice_segments_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                       5u32) as u32)
        }
    }
    #[inline]
    pub fn set_dependent_slice_segments_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn pps_slice_chroma_qp_offsets_present_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (64usize as u32)) >>
                                       6u32) as u32)
        }
    }
    #[inline]
    pub fn set_pps_slice_chroma_qp_offsets_present_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(64usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (64usize as u32);
    }
    #[inline]
    pub fn sample_adaptive_offset_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (128usize as u32)) >>
                                       7u32) as u32)
        }
    }
    #[inline]
    pub fn set_sample_adaptive_offset_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(128usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 7u32) & (128usize as u32);
    }
    #[inline]
    pub fn deblocking_filter_override_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (256usize as u32)) >>
                                       8u32) as u32)
        }
    }
    #[inline]
    pub fn set_deblocking_filter_override_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(256usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 8u32) & (256usize as u32);
    }
    #[inline]
    pub fn pps_disable_deblocking_filter_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (512usize as u32)) >>
                                       9u32) as u32)
        }
    }
    #[inline]
    pub fn set_pps_disable_deblocking_filter_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(512usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 9u32) & (512usize as u32);
    }
    #[inline]
    pub fn slice_segment_header_extension_present_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1024usize as u32)) >>
                                       10u32) as u32)
        }
    }
    #[inline]
    pub fn set_slice_segment_header_extension_present_flag(&mut self,
                                                           val: u32) {
        self._bitfield_1 &= !(1024usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 10u32) & (1024usize as u32);
    }
    #[inline]
    pub fn RapPicFlag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2048usize as u32)) >>
                                       11u32) as u32)
        }
    }
    #[inline]
    pub fn set_RapPicFlag(&mut self, val: u32) {
        self._bitfield_1 &= !(2048usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 11u32) & (2048usize as u32);
    }
    #[inline]
    pub fn IdrPicFlag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4096usize as u32)) >>
                                       12u32) as u32)
        }
    }
    #[inline]
    pub fn set_IdrPicFlag(&mut self, val: u32) {
        self._bitfield_1 &= !(4096usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (4096usize as u32);
    }
    #[inline]
    pub fn IntraPicFlag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8192usize as u32)) >>
                                       13u32) as u32)
        }
    }
    #[inline]
    pub fn set_IntraPicFlag(&mut self, val: u32) {
        self._bitfield_1 &= !(8192usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 13u32) & (8192usize as u32);
    }
    #[inline]
    pub fn ReservedBits(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (4294950912usize as u32)) >> 14u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_ReservedBits(&mut self, val: u32) {
        self._bitfield_1 &= !(4294950912usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (4294950912usize as u32);
    }
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferHEVC__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferHEVC__bindgen_ty_2>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferHEVC__bindgen_ty_2>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferHEVC__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferHEVC() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferHEVC>() ,
               316usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferHEVC>() ,
               4usize);
}
impl Clone for _VAPictureParameterBufferHEVC {
    fn clone(&self) -> Self { *self }
}
pub type VAPictureParameterBufferHEVC = _VAPictureParameterBufferHEVC;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VASliceParameterBufferBaseHEVC {
    pub slice_data_size: u32,
    pub slice_data_offset: u32,
    pub slice_data_flag: u16,
}
#[test]
fn bindgen_test_layout__VASliceParameterBufferBaseHEVC() {
    assert_eq!(::std::mem::size_of::<_VASliceParameterBufferBaseHEVC>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<_VASliceParameterBufferBaseHEVC>() ,
               4usize);
}
impl Clone for _VASliceParameterBufferBaseHEVC {
    fn clone(&self) -> Self { *self }
}
pub type VASliceParameterBufferBaseHEVC = _VASliceParameterBufferBaseHEVC;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VASliceParameterBufferHEVC {
    pub slice_data_size: u32,
    pub slice_data_offset: u32,
    pub slice_data_flag: u16,
    pub slice_data_byte_offset: u32,
    pub slice_segment_address: u32,
    pub RefPicList: [[u8; 15usize]; 2usize],
    pub LongSliceFlags: _VASliceParameterBufferHEVC__bindgen_ty_1,
    pub collocated_ref_idx: u8,
    pub num_ref_idx_l0_active_minus1: u8,
    pub num_ref_idx_l1_active_minus1: u8,
    pub slice_qp_delta: i8,
    pub slice_cb_qp_offset: i8,
    pub slice_cr_qp_offset: i8,
    pub slice_beta_offset_div2: i8,
    pub slice_tc_offset_div2: i8,
    pub luma_log2_weight_denom: u8,
    pub delta_chroma_log2_weight_denom: i8,
    pub delta_luma_weight_l0: [i8; 15usize],
    pub luma_offset_l0: [i8; 15usize],
    pub delta_chroma_weight_l0: [[i8; 2usize]; 15usize],
    pub ChromaOffsetL0: [[i8; 2usize]; 15usize],
    pub delta_luma_weight_l1: [i8; 15usize],
    pub luma_offset_l1: [i8; 15usize],
    pub delta_chroma_weight_l1: [[i8; 2usize]; 15usize],
    pub ChromaOffsetL1: [[i8; 2usize]; 15usize],
    pub five_minus_max_num_merge_cand: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VASliceParameterBufferHEVC__bindgen_ty_1 {
    pub value: __BindgenUnionField<u32>,
    pub fields: __BindgenUnionField<_VASliceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VASliceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__VASliceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VASliceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VASliceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VASliceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VASliceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn LastSliceOfPic(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_LastSliceOfPic(&mut self, val: u32) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn dependent_slice_segment_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_dependent_slice_segment_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn slice_type(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (12usize as u32)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_slice_type(&mut self, val: u32) {
        self._bitfield_1 &= !(12usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (12usize as u32);
    }
    #[inline]
    pub fn color_plane_id(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (48usize as u32)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_color_plane_id(&mut self, val: u32) {
        self._bitfield_1 &= !(48usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (48usize as u32);
    }
    #[inline]
    pub fn slice_sao_luma_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (64usize as u32)) >>
                                       6u32) as u32)
        }
    }
    #[inline]
    pub fn set_slice_sao_luma_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(64usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (64usize as u32);
    }
    #[inline]
    pub fn slice_sao_chroma_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (128usize as u32)) >>
                                       7u32) as u32)
        }
    }
    #[inline]
    pub fn set_slice_sao_chroma_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(128usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 7u32) & (128usize as u32);
    }
    #[inline]
    pub fn mvd_l1_zero_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (256usize as u32)) >>
                                       8u32) as u32)
        }
    }
    #[inline]
    pub fn set_mvd_l1_zero_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(256usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 8u32) & (256usize as u32);
    }
    #[inline]
    pub fn cabac_init_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (512usize as u32)) >>
                                       9u32) as u32)
        }
    }
    #[inline]
    pub fn set_cabac_init_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(512usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 9u32) & (512usize as u32);
    }
    #[inline]
    pub fn slice_temporal_mvp_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1024usize as u32)) >>
                                       10u32) as u32)
        }
    }
    #[inline]
    pub fn set_slice_temporal_mvp_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(1024usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 10u32) & (1024usize as u32);
    }
    #[inline]
    pub fn slice_deblocking_filter_disabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2048usize as u32)) >>
                                       11u32) as u32)
        }
    }
    #[inline]
    pub fn set_slice_deblocking_filter_disabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(2048usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 11u32) & (2048usize as u32);
    }
    #[inline]
    pub fn collocated_from_l0_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4096usize as u32)) >>
                                       12u32) as u32)
        }
    }
    #[inline]
    pub fn set_collocated_from_l0_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(4096usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (4096usize as u32);
    }
    #[inline]
    pub fn slice_loop_filter_across_slices_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8192usize as u32)) >>
                                       13u32) as u32)
        }
    }
    #[inline]
    pub fn set_slice_loop_filter_across_slices_enabled_flag(&mut self,
                                                            val: u32) {
        self._bitfield_1 &= !(8192usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 13u32) & (8192usize as u32);
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (4294950912usize as u32)) >> 14u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        self._bitfield_1 &= !(4294950912usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (4294950912usize as u32);
    }
}
#[test]
fn bindgen_test_layout__VASliceParameterBufferHEVC__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VASliceParameterBufferHEVC__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VASliceParameterBufferHEVC__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VASliceParameterBufferHEVC__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VASliceParameterBufferHEVC() {
    assert_eq!(::std::mem::size_of::<_VASliceParameterBufferHEVC>() ,
               248usize);
    assert_eq!(::std::mem::align_of::<_VASliceParameterBufferHEVC>() ,
               4usize);
}
impl Clone for _VASliceParameterBufferHEVC {
    fn clone(&self) -> Self { *self }
}
pub type VASliceParameterBufferHEVC = _VASliceParameterBufferHEVC;
#[repr(C)]
#[derive(Copy)]
pub struct _VAIQMatrixBufferHEVC {
    pub ScalingList4x4: [[u8; 16usize]; 6usize],
    pub ScalingList8x8: [[u8; 64usize]; 6usize],
    pub ScalingList16x16: [[u8; 64usize]; 6usize],
    pub ScalingList32x32: [[u8; 64usize]; 2usize],
    pub ScalingListDC16x16: [u8; 6usize],
    pub ScalingListDC32x32: [u8; 2usize],
}
#[test]
fn bindgen_test_layout__VAIQMatrixBufferHEVC() {
    assert_eq!(::std::mem::size_of::<_VAIQMatrixBufferHEVC>() , 1000usize);
    assert_eq!(::std::mem::align_of::<_VAIQMatrixBufferHEVC>() , 1usize);
}
impl Clone for _VAIQMatrixBufferHEVC {
    fn clone(&self) -> Self { *self }
}
pub type VAIQMatrixBufferHEVC = _VAIQMatrixBufferHEVC;
#[repr(C)]
pub struct _VAPictureParameterBufferJPEGBaseline {
    pub picture_width: ::std::os::raw::c_ushort,
    pub picture_height: ::std::os::raw::c_ushort,
    pub components: [_VAPictureParameterBufferJPEGBaseline__bindgen_ty_1; 255usize],
    pub num_components: ::std::os::raw::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferJPEGBaseline__bindgen_ty_1 {
    pub component_id: ::std::os::raw::c_uchar,
    pub h_sampling_factor: ::std::os::raw::c_uchar,
    pub v_sampling_factor: ::std::os::raw::c_uchar,
    pub quantiser_table_selector: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferJPEGBaseline__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferJPEGBaseline__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferJPEGBaseline__bindgen_ty_1>()
               , 1usize);
}
impl Clone for _VAPictureParameterBufferJPEGBaseline__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferJPEGBaseline() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferJPEGBaseline>()
               , 1026usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferJPEGBaseline>()
               , 2usize);
}
pub type VAPictureParameterBufferJPEGBaseline =
    _VAPictureParameterBufferJPEGBaseline;
#[repr(C)]
#[derive(Copy)]
pub struct _VAIQMatrixBufferJPEGBaseline {
    pub load_quantiser_table: [::std::os::raw::c_uchar; 4usize],
    pub quantiser_table: [[::std::os::raw::c_uchar; 64usize]; 4usize],
}
#[test]
fn bindgen_test_layout__VAIQMatrixBufferJPEGBaseline() {
    assert_eq!(::std::mem::size_of::<_VAIQMatrixBufferJPEGBaseline>() ,
               260usize);
    assert_eq!(::std::mem::align_of::<_VAIQMatrixBufferJPEGBaseline>() ,
               1usize);
}
impl Clone for _VAIQMatrixBufferJPEGBaseline {
    fn clone(&self) -> Self { *self }
}
pub type VAIQMatrixBufferJPEGBaseline = _VAIQMatrixBufferJPEGBaseline;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VASliceParameterBufferJPEGBaseline {
    pub slice_data_size: ::std::os::raw::c_uint,
    pub slice_data_offset: ::std::os::raw::c_uint,
    pub slice_data_flag: ::std::os::raw::c_uint,
    pub slice_horizontal_position: ::std::os::raw::c_uint,
    pub slice_vertical_position: ::std::os::raw::c_uint,
    pub components: [_VASliceParameterBufferJPEGBaseline__bindgen_ty_1; 4usize],
    pub num_components: ::std::os::raw::c_uchar,
    pub restart_interval: ::std::os::raw::c_ushort,
    pub num_mcus: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VASliceParameterBufferJPEGBaseline__bindgen_ty_1 {
    pub component_selector: ::std::os::raw::c_uchar,
    pub dc_table_selector: ::std::os::raw::c_uchar,
    pub ac_table_selector: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout__VASliceParameterBufferJPEGBaseline__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VASliceParameterBufferJPEGBaseline__bindgen_ty_1>()
               , 3usize);
    assert_eq!(::std::mem::align_of::<_VASliceParameterBufferJPEGBaseline__bindgen_ty_1>()
               , 1usize);
}
impl Clone for _VASliceParameterBufferJPEGBaseline__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VASliceParameterBufferJPEGBaseline() {
    assert_eq!(::std::mem::size_of::<_VASliceParameterBufferJPEGBaseline>() ,
               40usize);
    assert_eq!(::std::mem::align_of::<_VASliceParameterBufferJPEGBaseline>() ,
               4usize);
}
impl Clone for _VASliceParameterBufferJPEGBaseline {
    fn clone(&self) -> Self { *self }
}
pub type VASliceParameterBufferJPEGBaseline =
    _VASliceParameterBufferJPEGBaseline;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VABoolCoderContextVPX {
    pub range: ::std::os::raw::c_uchar,
    pub value: ::std::os::raw::c_uchar,
    pub count: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout__VABoolCoderContextVPX() {
    assert_eq!(::std::mem::size_of::<_VABoolCoderContextVPX>() , 3usize);
    assert_eq!(::std::mem::align_of::<_VABoolCoderContextVPX>() , 1usize);
}
impl Clone for _VABoolCoderContextVPX {
    fn clone(&self) -> Self { *self }
}
pub type VABoolCoderContextVPX = _VABoolCoderContextVPX;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferVP8 {
    pub frame_width: ::std::os::raw::c_uint,
    pub frame_height: ::std::os::raw::c_uint,
    pub last_ref_frame: VASurfaceID,
    pub golden_ref_frame: VASurfaceID,
    pub alt_ref_frame: VASurfaceID,
    pub out_of_loop_frame: VASurfaceID,
    pub pic_fields: _VAPictureParameterBufferVP8__bindgen_ty_1,
    pub mb_segment_tree_probs: [::std::os::raw::c_uchar; 3usize],
    pub loop_filter_level: [::std::os::raw::c_uchar; 4usize],
    pub loop_filter_deltas_ref_frame: [::std::os::raw::c_char; 4usize],
    pub loop_filter_deltas_mode: [::std::os::raw::c_char; 4usize],
    pub prob_skip_false: ::std::os::raw::c_uchar,
    pub prob_intra: ::std::os::raw::c_uchar,
    pub prob_last: ::std::os::raw::c_uchar,
    pub prob_gf: ::std::os::raw::c_uchar,
    pub y_mode_probs: [::std::os::raw::c_uchar; 4usize],
    pub uv_mode_probs: [::std::os::raw::c_uchar; 3usize],
    pub mv_probs: [[::std::os::raw::c_uchar; 19usize]; 2usize],
    pub bool_coder_ctx: VABoolCoderContextVPX,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferVP8__bindgen_ty_1 {
    pub bits: __BindgenUnionField<_VAPictureParameterBufferVP8__bindgen_ty_1__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAPictureParameterBufferVP8__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferVP8__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferVP8__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferVP8__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferVP8__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAPictureParameterBufferVP8__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn key_frame(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_key_frame(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn version(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (14usize as u32)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_version(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(14usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (14usize as u32);
    }
    #[inline]
    pub fn segmentation_enabled(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_segmentation_enabled(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn update_mb_segmentation_map(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                       5u32) as u32)
        }
    }
    #[inline]
    pub fn set_update_mb_segmentation_map(&mut self,
                                          val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn update_segment_feature_data(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (64usize as u32)) >>
                                       6u32) as u32)
        }
    }
    #[inline]
    pub fn set_update_segment_feature_data(&mut self,
                                           val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(64usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (64usize as u32);
    }
    #[inline]
    pub fn filter_type(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (128usize as u32)) >>
                                       7u32) as u32)
        }
    }
    #[inline]
    pub fn set_filter_type(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(128usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 7u32) & (128usize as u32);
    }
    #[inline]
    pub fn sharpness_level(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1792usize as u32)) >>
                                       8u32) as u32)
        }
    }
    #[inline]
    pub fn set_sharpness_level(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1792usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 8u32) & (1792usize as u32);
    }
    #[inline]
    pub fn loop_filter_adj_enable(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2048usize as u32)) >>
                                       11u32) as u32)
        }
    }
    #[inline]
    pub fn set_loop_filter_adj_enable(&mut self,
                                      val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(2048usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 11u32) & (2048usize as u32);
    }
    #[inline]
    pub fn mode_ref_lf_delta_update(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4096usize as u32)) >>
                                       12u32) as u32)
        }
    }
    #[inline]
    pub fn set_mode_ref_lf_delta_update(&mut self,
                                        val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4096usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (4096usize as u32);
    }
    #[inline]
    pub fn sign_bias_golden(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8192usize as u32)) >>
                                       13u32) as u32)
        }
    }
    #[inline]
    pub fn set_sign_bias_golden(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(8192usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 13u32) & (8192usize as u32);
    }
    #[inline]
    pub fn sign_bias_alternate(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16384usize as u32)) >>
                                       14u32) as u32)
        }
    }
    #[inline]
    pub fn set_sign_bias_alternate(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(16384usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (16384usize as u32);
    }
    #[inline]
    pub fn mb_no_coeff_skip(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32768usize as u32)) >>
                                       15u32) as u32)
        }
    }
    #[inline]
    pub fn set_mb_no_coeff_skip(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(32768usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 15u32) & (32768usize as u32);
    }
    #[inline]
    pub fn loop_filter_disable(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (65536usize as u32)) >>
                                       16u32) as u32)
        }
    }
    #[inline]
    pub fn set_loop_filter_disable(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(65536usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (65536usize as u32);
    }
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferVP8__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferVP8__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferVP8__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAPictureParameterBufferVP8__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VAPictureParameterBufferVP8() {
    assert_eq!(::std::mem::size_of::<_VAPictureParameterBufferVP8>() ,
               96usize);
    assert_eq!(::std::mem::align_of::<_VAPictureParameterBufferVP8>() ,
               4usize);
}
impl Clone for _VAPictureParameterBufferVP8 {
    fn clone(&self) -> Self { *self }
}
pub type VAPictureParameterBufferVP8 = _VAPictureParameterBufferVP8;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VASliceParameterBufferVP8 {
    pub slice_data_size: ::std::os::raw::c_uint,
    pub slice_data_offset: ::std::os::raw::c_uint,
    pub slice_data_flag: ::std::os::raw::c_uint,
    pub macroblock_offset: ::std::os::raw::c_uint,
    pub num_of_partitions: ::std::os::raw::c_uchar,
    pub partition_size: [::std::os::raw::c_uint; 9usize],
}
#[test]
fn bindgen_test_layout__VASliceParameterBufferVP8() {
    assert_eq!(::std::mem::size_of::<_VASliceParameterBufferVP8>() , 56usize);
    assert_eq!(::std::mem::align_of::<_VASliceParameterBufferVP8>() , 4usize);
}
impl Clone for _VASliceParameterBufferVP8 {
    fn clone(&self) -> Self { *self }
}
pub type VASliceParameterBufferVP8 = _VASliceParameterBufferVP8;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAProbabilityDataBufferVP8 {
    pub dct_coeff_probs: [[[[::std::os::raw::c_uchar; 11usize]; 3usize]; 8usize]; 4usize],
}
#[test]
fn bindgen_test_layout__VAProbabilityDataBufferVP8() {
    assert_eq!(::std::mem::size_of::<_VAProbabilityDataBufferVP8>() ,
               1056usize);
    assert_eq!(::std::mem::align_of::<_VAProbabilityDataBufferVP8>() ,
               1usize);
}
impl Clone for _VAProbabilityDataBufferVP8 {
    fn clone(&self) -> Self { *self }
}
pub type VAProbabilityDataBufferVP8 = _VAProbabilityDataBufferVP8;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAIQMatrixBufferVP8 {
    pub quantization_index: [[::std::os::raw::c_ushort; 6usize]; 4usize],
}
#[test]
fn bindgen_test_layout__VAIQMatrixBufferVP8() {
    assert_eq!(::std::mem::size_of::<_VAIQMatrixBufferVP8>() , 48usize);
    assert_eq!(::std::mem::align_of::<_VAIQMatrixBufferVP8>() , 2usize);
}
impl Clone for _VAIQMatrixBufferVP8 {
    fn clone(&self) -> Self { *self }
}
pub type VAIQMatrixBufferVP8 = _VAIQMatrixBufferVP8;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VADecPictureParameterBufferVP9 {
    pub frame_width: u16,
    pub frame_height: u16,
    pub reference_frames: [VASurfaceID; 8usize],
    pub pic_fields: _VADecPictureParameterBufferVP9__bindgen_ty_1,
    pub filter_level: u8,
    pub sharpness_level: u8,
    pub log2_tile_rows: u8,
    pub log2_tile_columns: u8,
    pub frame_header_length_in_bytes: u8,
    pub first_partition_size: u16,
    pub mb_segment_tree_probs: [u8; 7usize],
    pub segment_pred_probs: [u8; 3usize],
    pub profile: u8,
    pub bit_depth: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VADecPictureParameterBufferVP9__bindgen_ty_1 {
    pub bits: __BindgenUnionField<_VADecPictureParameterBufferVP9__bindgen_ty_1__bindgen_ty_1>,
    pub value: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VADecPictureParameterBufferVP9__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__VADecPictureParameterBufferVP9__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VADecPictureParameterBufferVP9__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VADecPictureParameterBufferVP9__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VADecPictureParameterBufferVP9__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VADecPictureParameterBufferVP9__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn subsampling_x(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_subsampling_x(&mut self, val: u32) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn subsampling_y(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_subsampling_y(&mut self, val: u32) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn frame_type(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_frame_type(&mut self, val: u32) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn show_frame(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                       3u32) as u32)
        }
    }
    #[inline]
    pub fn set_show_frame(&mut self, val: u32) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn error_resilient_mode(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_error_resilient_mode(&mut self, val: u32) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn intra_only(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                       5u32) as u32)
        }
    }
    #[inline]
    pub fn set_intra_only(&mut self, val: u32) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn allow_high_precision_mv(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (64usize as u32)) >>
                                       6u32) as u32)
        }
    }
    #[inline]
    pub fn set_allow_high_precision_mv(&mut self, val: u32) {
        self._bitfield_1 &= !(64usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (64usize as u32);
    }
    #[inline]
    pub fn mcomp_filter_type(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (896usize as u32)) >>
                                       7u32) as u32)
        }
    }
    #[inline]
    pub fn set_mcomp_filter_type(&mut self, val: u32) {
        self._bitfield_1 &= !(896usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 7u32) & (896usize as u32);
    }
    #[inline]
    pub fn frame_parallel_decoding_mode(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1024usize as u32)) >>
                                       10u32) as u32)
        }
    }
    #[inline]
    pub fn set_frame_parallel_decoding_mode(&mut self, val: u32) {
        self._bitfield_1 &= !(1024usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 10u32) & (1024usize as u32);
    }
    #[inline]
    pub fn reset_frame_context(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (6144usize as u32)) >>
                                       11u32) as u32)
        }
    }
    #[inline]
    pub fn set_reset_frame_context(&mut self, val: u32) {
        self._bitfield_1 &= !(6144usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 11u32) & (6144usize as u32);
    }
    #[inline]
    pub fn refresh_frame_context(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8192usize as u32)) >>
                                       13u32) as u32)
        }
    }
    #[inline]
    pub fn set_refresh_frame_context(&mut self, val: u32) {
        self._bitfield_1 &= !(8192usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 13u32) & (8192usize as u32);
    }
    #[inline]
    pub fn frame_context_idx(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (49152usize as u32)) >>
                                       14u32) as u32)
        }
    }
    #[inline]
    pub fn set_frame_context_idx(&mut self, val: u32) {
        self._bitfield_1 &= !(49152usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (49152usize as u32);
    }
    #[inline]
    pub fn segmentation_enabled(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (65536usize as u32)) >>
                                       16u32) as u32)
        }
    }
    #[inline]
    pub fn set_segmentation_enabled(&mut self, val: u32) {
        self._bitfield_1 &= !(65536usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (65536usize as u32);
    }
    #[inline]
    pub fn segmentation_temporal_update(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (131072usize as u32))
                                       >> 17u32) as u32)
        }
    }
    #[inline]
    pub fn set_segmentation_temporal_update(&mut self, val: u32) {
        self._bitfield_1 &= !(131072usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 17u32) & (131072usize as u32);
    }
    #[inline]
    pub fn segmentation_update_map(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (262144usize as u32))
                                       >> 18u32) as u32)
        }
    }
    #[inline]
    pub fn set_segmentation_update_map(&mut self, val: u32) {
        self._bitfield_1 &= !(262144usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 18u32) & (262144usize as u32);
    }
    #[inline]
    pub fn last_ref_frame(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (3670016usize as u32))
                                       >> 19u32) as u32)
        }
    }
    #[inline]
    pub fn set_last_ref_frame(&mut self, val: u32) {
        self._bitfield_1 &= !(3670016usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 19u32) & (3670016usize as u32);
    }
    #[inline]
    pub fn last_ref_frame_sign_bias(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4194304usize as u32))
                                       >> 22u32) as u32)
        }
    }
    #[inline]
    pub fn set_last_ref_frame_sign_bias(&mut self, val: u32) {
        self._bitfield_1 &= !(4194304usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 22u32) & (4194304usize as u32);
    }
    #[inline]
    pub fn golden_ref_frame(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (58720256usize as u32))
                                       >> 23u32) as u32)
        }
    }
    #[inline]
    pub fn set_golden_ref_frame(&mut self, val: u32) {
        self._bitfield_1 &= !(58720256usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 23u32) & (58720256usize as u32);
    }
    #[inline]
    pub fn golden_ref_frame_sign_bias(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (67108864usize as u32))
                                       >> 26u32) as u32)
        }
    }
    #[inline]
    pub fn set_golden_ref_frame_sign_bias(&mut self, val: u32) {
        self._bitfield_1 &= !(67108864usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 26u32) & (67108864usize as u32);
    }
    #[inline]
    pub fn alt_ref_frame(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (939524096usize as u32)) >> 27u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_alt_ref_frame(&mut self, val: u32) {
        self._bitfield_1 &= !(939524096usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 27u32) & (939524096usize as u32);
    }
    #[inline]
    pub fn alt_ref_frame_sign_bias(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (1073741824usize as u32)) >> 30u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_alt_ref_frame_sign_bias(&mut self, val: u32) {
        self._bitfield_1 &= !(1073741824usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 30u32) & (1073741824usize as u32);
    }
    #[inline]
    pub fn lossless_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (2147483648usize as u32)) >> 31u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_lossless_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(2147483648usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 31u32) & (2147483648usize as u32);
    }
}
#[test]
fn bindgen_test_layout__VADecPictureParameterBufferVP9__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VADecPictureParameterBufferVP9__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VADecPictureParameterBufferVP9__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VADecPictureParameterBufferVP9__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VADecPictureParameterBufferVP9() {
    assert_eq!(::std::mem::size_of::<_VADecPictureParameterBufferVP9>() ,
               60usize);
    assert_eq!(::std::mem::align_of::<_VADecPictureParameterBufferVP9>() ,
               4usize);
}
impl Clone for _VADecPictureParameterBufferVP9 {
    fn clone(&self) -> Self { *self }
}
pub type VADecPictureParameterBufferVP9 = _VADecPictureParameterBufferVP9;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VASegmentParameterVP9 {
    pub segment_flags: _VASegmentParameterVP9__bindgen_ty_1,
    pub filter_level: [[u8; 2usize]; 4usize],
    pub luma_ac_quant_scale: i16,
    pub luma_dc_quant_scale: i16,
    pub chroma_ac_quant_scale: i16,
    pub chroma_dc_quant_scale: i16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VASegmentParameterVP9__bindgen_ty_1 {
    pub fields: __BindgenUnionField<_VASegmentParameterVP9__bindgen_ty_1__bindgen_ty_1>,
    pub value: __BindgenUnionField<u16>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VASegmentParameterVP9__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout__VASegmentParameterVP9__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VASegmentParameterVP9__bindgen_ty_1__bindgen_ty_1>()
               , 2usize);
    assert_eq!(::std::mem::align_of::<_VASegmentParameterVP9__bindgen_ty_1__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _VASegmentParameterVP9__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VASegmentParameterVP9__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn segment_reference_enabled(&self) -> u16 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                       0u32) as u16)
        }
    }
    #[inline]
    pub fn set_segment_reference_enabled(&mut self, val: u16) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u16 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn segment_reference(&self) -> u16 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (6usize as u8)) >>
                                       1u32) as u16)
        }
    }
    #[inline]
    pub fn set_segment_reference(&mut self, val: u16) {
        self._bitfield_1 &= !(6usize as u8);
        self._bitfield_1 |= ((val as u16 as u8) << 1u32) & (6usize as u8);
    }
    #[inline]
    pub fn segment_reference_skipped(&self) -> u16 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8usize as u8)) >>
                                       3u32) as u16)
        }
    }
    #[inline]
    pub fn set_segment_reference_skipped(&mut self, val: u16) {
        self._bitfield_1 &= !(8usize as u8);
        self._bitfield_1 |= ((val as u16 as u8) << 3u32) & (8usize as u8);
    }
}
#[test]
fn bindgen_test_layout__VASegmentParameterVP9__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VASegmentParameterVP9__bindgen_ty_1>() ,
               2usize);
    assert_eq!(::std::mem::align_of::<_VASegmentParameterVP9__bindgen_ty_1>()
               , 2usize);
}
impl Clone for _VASegmentParameterVP9__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VASegmentParameterVP9() {
    assert_eq!(::std::mem::size_of::<_VASegmentParameterVP9>() , 18usize);
    assert_eq!(::std::mem::align_of::<_VASegmentParameterVP9>() , 2usize);
}
impl Clone for _VASegmentParameterVP9 {
    fn clone(&self) -> Self { *self }
}
pub type VASegmentParameterVP9 = _VASegmentParameterVP9;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VASliceParameterBufferVP9 {
    pub slice_data_size: u32,
    pub slice_data_offset: u32,
    pub slice_data_flag: u32,
    pub seg_param: [VASegmentParameterVP9; 8usize],
}
#[test]
fn bindgen_test_layout__VASliceParameterBufferVP9() {
    assert_eq!(::std::mem::size_of::<_VASliceParameterBufferVP9>() ,
               156usize);
    assert_eq!(::std::mem::align_of::<_VASliceParameterBufferVP9>() , 4usize);
}
impl Clone for _VASliceParameterBufferVP9 {
    fn clone(&self) -> Self { *self }
}
pub type VASliceParameterBufferVP9 = _VASliceParameterBufferVP9;
pub const VAEncPackedHeaderHEVC_VPS: _bindgen_ty_17 =
    _bindgen_ty_17::VAEncPackedHeaderHEVC_VPS;
pub const VAEncPackedHeaderHEVC_SPS: _bindgen_ty_17 =
    _bindgen_ty_17::VAEncPackedHeaderHEVC_VPS;
pub const VAEncPackedHeaderHEVC_PPS: _bindgen_ty_17 =
    _bindgen_ty_17::VAEncPackedHeaderHEVC_PPS;
pub const VAEncPackedHeaderHEVC_Slice: _bindgen_ty_17 =
    _bindgen_ty_17::VAEncPackedHeaderHEVC_Slice;
pub const VAEncPackedHeaderHEVC_SEI: _bindgen_ty_17 =
    _bindgen_ty_17::VAEncPackedHeaderHEVC_SEI;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_17 {
    VAEncPackedHeaderHEVC_VPS = 1,
    VAEncPackedHeaderHEVC_PPS = 2,
    VAEncPackedHeaderHEVC_Slice = 3,
    VAEncPackedHeaderHEVC_SEI = 2147483649,
}
pub use self::_bindgen_ty_17 as VAEncPackedHeaderTypeHEVC;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSequenceParameterBufferHEVC {
    pub general_profile_idc: u8,
    pub general_level_idc: u8,
    pub general_tier_flag: u8,
    pub intra_period: u32,
    pub intra_idr_period: u32,
    pub ip_period: u32,
    pub bits_per_second: u32,
    pub pic_width_in_luma_samples: u16,
    pub pic_height_in_luma_samples: u16,
    pub seq_fields: _VAEncSequenceParameterBufferHEVC__bindgen_ty_1,
    pub log2_min_luma_coding_block_size_minus3: u8,
    pub log2_diff_max_min_luma_coding_block_size: u8,
    pub log2_min_transform_block_size_minus2: u8,
    pub log2_diff_max_min_transform_block_size: u8,
    pub max_transform_hierarchy_depth_inter: u8,
    pub max_transform_hierarchy_depth_intra: u8,
    pub pcm_sample_bit_depth_luma_minus1: u32,
    pub pcm_sample_bit_depth_chroma_minus1: u32,
    pub log2_min_pcm_luma_coding_block_size_minus3: u32,
    pub log2_max_pcm_luma_coding_block_size_minus3: u32,
    pub vui_parameters_present_flag: u8,
    pub vui_fields: _VAEncSequenceParameterBufferHEVC__bindgen_ty_2,
    pub aspect_ratio_idc: u8,
    pub sar_width: u32,
    pub sar_height: u32,
    pub vui_num_units_in_tick: u32,
    pub vui_time_scale: u32,
    pub min_spatial_segmentation_idc: u16,
    pub max_bytes_per_pic_denom: u8,
    pub max_bits_per_min_cu_denom: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSequenceParameterBufferHEVC__bindgen_ty_1 {
    pub bits: __BindgenUnionField<_VAEncSequenceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1>,
    pub value: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSequenceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__VAEncSequenceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncSequenceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncSequenceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncSequenceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAEncSequenceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn chroma_format_idc(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (3usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_chroma_format_idc(&mut self, val: u32) {
        self._bitfield_1 &= !(3usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (3usize as u32);
    }
    #[inline]
    pub fn separate_colour_plane_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_separate_colour_plane_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn bit_depth_luma_minus8(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (56usize as u32)) >>
                                       3u32) as u32)
        }
    }
    #[inline]
    pub fn set_bit_depth_luma_minus8(&mut self, val: u32) {
        self._bitfield_1 &= !(56usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (56usize as u32);
    }
    #[inline]
    pub fn bit_depth_chroma_minus8(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (448usize as u32)) >>
                                       6u32) as u32)
        }
    }
    #[inline]
    pub fn set_bit_depth_chroma_minus8(&mut self, val: u32) {
        self._bitfield_1 &= !(448usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (448usize as u32);
    }
    #[inline]
    pub fn scaling_list_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (512usize as u32)) >>
                                       9u32) as u32)
        }
    }
    #[inline]
    pub fn set_scaling_list_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(512usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 9u32) & (512usize as u32);
    }
    #[inline]
    pub fn strong_intra_smoothing_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1024usize as u32)) >>
                                       10u32) as u32)
        }
    }
    #[inline]
    pub fn set_strong_intra_smoothing_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(1024usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 10u32) & (1024usize as u32);
    }
    #[inline]
    pub fn amp_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2048usize as u32)) >>
                                       11u32) as u32)
        }
    }
    #[inline]
    pub fn set_amp_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(2048usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 11u32) & (2048usize as u32);
    }
    #[inline]
    pub fn sample_adaptive_offset_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4096usize as u32)) >>
                                       12u32) as u32)
        }
    }
    #[inline]
    pub fn set_sample_adaptive_offset_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(4096usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (4096usize as u32);
    }
    #[inline]
    pub fn pcm_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8192usize as u32)) >>
                                       13u32) as u32)
        }
    }
    #[inline]
    pub fn set_pcm_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(8192usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 13u32) & (8192usize as u32);
    }
    #[inline]
    pub fn pcm_loop_filter_disabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16384usize as u32)) >>
                                       14u32) as u32)
        }
    }
    #[inline]
    pub fn set_pcm_loop_filter_disabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(16384usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (16384usize as u32);
    }
    #[inline]
    pub fn sps_temporal_mvp_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32768usize as u32)) >>
                                       15u32) as u32)
        }
    }
    #[inline]
    pub fn set_sps_temporal_mvp_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(32768usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 15u32) & (32768usize as u32);
    }
    #[inline]
    pub fn reserved_bits(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (4294901760usize as u32)) >> 16u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_reserved_bits(&mut self, val: u32) {
        self._bitfield_1 &= !(4294901760usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (4294901760usize as u32);
    }
}
#[test]
fn bindgen_test_layout__VAEncSequenceParameterBufferHEVC__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncSequenceParameterBufferHEVC__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncSequenceParameterBufferHEVC__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncSequenceParameterBufferHEVC__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSequenceParameterBufferHEVC__bindgen_ty_2 {
    pub bits: __BindgenUnionField<_VAEncSequenceParameterBufferHEVC__bindgen_ty_2__bindgen_ty_1>,
    pub value: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSequenceParameterBufferHEVC__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__VAEncSequenceParameterBufferHEVC__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncSequenceParameterBufferHEVC__bindgen_ty_2__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncSequenceParameterBufferHEVC__bindgen_ty_2__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncSequenceParameterBufferHEVC__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAEncSequenceParameterBufferHEVC__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn aspect_ratio_info_present_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_aspect_ratio_info_present_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn neutral_chroma_indication_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_neutral_chroma_indication_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn field_seq_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_field_seq_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn vui_timing_info_present_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                       3u32) as u32)
        }
    }
    #[inline]
    pub fn set_vui_timing_info_present_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn bitstream_restriction_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_bitstream_restriction_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn tiles_fixed_structure_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                       5u32) as u32)
        }
    }
    #[inline]
    pub fn set_tiles_fixed_structure_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn motion_vectors_over_pic_boundaries_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (64usize as u32)) >>
                                       6u32) as u32)
        }
    }
    #[inline]
    pub fn set_motion_vectors_over_pic_boundaries_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(64usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (64usize as u32);
    }
    #[inline]
    pub fn restricted_ref_pic_lists_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (128usize as u32)) >>
                                       7u32) as u32)
        }
    }
    #[inline]
    pub fn set_restricted_ref_pic_lists_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(128usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 7u32) & (128usize as u32);
    }
    #[inline]
    pub fn log2_max_mv_length_horizontal(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (7936usize as u32)) >>
                                       8u32) as u32)
        }
    }
    #[inline]
    pub fn set_log2_max_mv_length_horizontal(&mut self, val: u32) {
        self._bitfield_1 &= !(7936usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 8u32) & (7936usize as u32);
    }
    #[inline]
    pub fn log2_max_mv_length_vertical(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (253952usize as u32))
                                       >> 13u32) as u32)
        }
    }
    #[inline]
    pub fn set_log2_max_mv_length_vertical(&mut self, val: u32) {
        self._bitfield_1 &= !(253952usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 13u32) & (253952usize as u32);
    }
}
#[test]
fn bindgen_test_layout__VAEncSequenceParameterBufferHEVC__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<_VAEncSequenceParameterBufferHEVC__bindgen_ty_2>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncSequenceParameterBufferHEVC__bindgen_ty_2>()
               , 4usize);
}
impl Clone for _VAEncSequenceParameterBufferHEVC__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VAEncSequenceParameterBufferHEVC() {
    assert_eq!(::std::mem::size_of::<_VAEncSequenceParameterBufferHEVC>() ,
               84usize);
    assert_eq!(::std::mem::align_of::<_VAEncSequenceParameterBufferHEVC>() ,
               4usize);
}
impl Clone for _VAEncSequenceParameterBufferHEVC {
    fn clone(&self) -> Self { *self }
}
pub type VAEncSequenceParameterBufferHEVC = _VAEncSequenceParameterBufferHEVC;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncPictureParameterBufferHEVC {
    pub decoded_curr_pic: VAPictureHEVC,
    pub reference_frames: [VAPictureHEVC; 15usize],
    pub coded_buf: VABufferID,
    pub collocated_ref_pic_index: u8,
    pub last_picture: u8,
    pub pic_init_qp: u8,
    pub diff_cu_qp_delta_depth: u8,
    pub pps_cb_qp_offset: i8,
    pub pps_cr_qp_offset: i8,
    pub num_tile_columns_minus1: u8,
    pub num_tile_rows_minus1: u8,
    pub column_width_minus1: [u8; 19usize],
    pub row_height_minus1: [u8; 21usize],
    pub log2_parallel_merge_level_minus2: u8,
    pub ctu_max_bitsize_allowed: u8,
    pub num_ref_idx_l0_default_active_minus1: u8,
    pub num_ref_idx_l1_default_active_minus1: u8,
    pub slice_pic_parameter_set_id: u8,
    pub nal_unit_type: u8,
    pub pic_fields: _VAEncPictureParameterBufferHEVC__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncPictureParameterBufferHEVC__bindgen_ty_1 {
    pub bits: __BindgenUnionField<_VAEncPictureParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1>,
    pub value: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncPictureParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__VAEncPictureParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncPictureParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncPictureParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncPictureParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAEncPictureParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn idr_pic_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_idr_pic_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn coding_type(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (14usize as u32)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_coding_type(&mut self, val: u32) {
        self._bitfield_1 &= !(14usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (14usize as u32);
    }
    #[inline]
    pub fn reference_pic_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_reference_pic_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn dependent_slice_segments_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                       5u32) as u32)
        }
    }
    #[inline]
    pub fn set_dependent_slice_segments_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn sign_data_hiding_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (64usize as u32)) >>
                                       6u32) as u32)
        }
    }
    #[inline]
    pub fn set_sign_data_hiding_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(64usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (64usize as u32);
    }
    #[inline]
    pub fn constrained_intra_pred_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (128usize as u32)) >>
                                       7u32) as u32)
        }
    }
    #[inline]
    pub fn set_constrained_intra_pred_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(128usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 7u32) & (128usize as u32);
    }
    #[inline]
    pub fn transform_skip_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (256usize as u32)) >>
                                       8u32) as u32)
        }
    }
    #[inline]
    pub fn set_transform_skip_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(256usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 8u32) & (256usize as u32);
    }
    #[inline]
    pub fn cu_qp_delta_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (512usize as u32)) >>
                                       9u32) as u32)
        }
    }
    #[inline]
    pub fn set_cu_qp_delta_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(512usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 9u32) & (512usize as u32);
    }
    #[inline]
    pub fn weighted_pred_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1024usize as u32)) >>
                                       10u32) as u32)
        }
    }
    #[inline]
    pub fn set_weighted_pred_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(1024usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 10u32) & (1024usize as u32);
    }
    #[inline]
    pub fn weighted_bipred_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2048usize as u32)) >>
                                       11u32) as u32)
        }
    }
    #[inline]
    pub fn set_weighted_bipred_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(2048usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 11u32) & (2048usize as u32);
    }
    #[inline]
    pub fn transquant_bypass_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4096usize as u32)) >>
                                       12u32) as u32)
        }
    }
    #[inline]
    pub fn set_transquant_bypass_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(4096usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (4096usize as u32);
    }
    #[inline]
    pub fn tiles_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8192usize as u32)) >>
                                       13u32) as u32)
        }
    }
    #[inline]
    pub fn set_tiles_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(8192usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 13u32) & (8192usize as u32);
    }
    #[inline]
    pub fn entropy_coding_sync_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16384usize as u32)) >>
                                       14u32) as u32)
        }
    }
    #[inline]
    pub fn set_entropy_coding_sync_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(16384usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (16384usize as u32);
    }
    #[inline]
    pub fn loop_filter_across_tiles_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32768usize as u32)) >>
                                       15u32) as u32)
        }
    }
    #[inline]
    pub fn set_loop_filter_across_tiles_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(32768usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 15u32) & (32768usize as u32);
    }
    #[inline]
    pub fn pps_loop_filter_across_slices_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (65536usize as u32)) >>
                                       16u32) as u32)
        }
    }
    #[inline]
    pub fn set_pps_loop_filter_across_slices_enabled_flag(&mut self,
                                                          val: u32) {
        self._bitfield_1 &= !(65536usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (65536usize as u32);
    }
    #[inline]
    pub fn scaling_list_data_present_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (131072usize as u32))
                                       >> 17u32) as u32)
        }
    }
    #[inline]
    pub fn set_scaling_list_data_present_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(131072usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 17u32) & (131072usize as u32);
    }
    #[inline]
    pub fn screen_content_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (262144usize as u32))
                                       >> 18u32) as u32)
        }
    }
    #[inline]
    pub fn set_screen_content_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(262144usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 18u32) & (262144usize as u32);
    }
    #[inline]
    pub fn enable_gpu_weighted_prediction(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (524288usize as u32))
                                       >> 19u32) as u32)
        }
    }
    #[inline]
    pub fn set_enable_gpu_weighted_prediction(&mut self, val: u32) {
        self._bitfield_1 &= !(524288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 19u32) & (524288usize as u32);
    }
    #[inline]
    pub fn no_output_of_prior_pics_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1048576usize as u32))
                                       >> 20u32) as u32)
        }
    }
    #[inline]
    pub fn set_no_output_of_prior_pics_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(1048576usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 20u32) & (1048576usize as u32);
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (4292870144usize as u32)) >> 21u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        self._bitfield_1 &= !(4292870144usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 21u32) & (4292870144usize as u32);
    }
}
#[test]
fn bindgen_test_layout__VAEncPictureParameterBufferHEVC__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncPictureParameterBufferHEVC__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncPictureParameterBufferHEVC__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncPictureParameterBufferHEVC__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VAEncPictureParameterBufferHEVC() {
    assert_eq!(::std::mem::size_of::<_VAEncPictureParameterBufferHEVC>() ,
               256usize);
    assert_eq!(::std::mem::align_of::<_VAEncPictureParameterBufferHEVC>() ,
               4usize);
}
impl Clone for _VAEncPictureParameterBufferHEVC {
    fn clone(&self) -> Self { *self }
}
pub type VAEncPictureParameterBufferHEVC = _VAEncPictureParameterBufferHEVC;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSliceParameterBufferHEVC {
    pub slice_segment_address: u32,
    pub num_ctu_in_slice: u32,
    pub slice_type: u8,
    pub slice_pic_parameter_set_id: u8,
    pub num_ref_idx_l0_active_minus1: u8,
    pub num_ref_idx_l1_active_minus1: u8,
    pub ref_pic_list0: [VAPictureHEVC; 15usize],
    pub ref_pic_list1: [VAPictureHEVC; 15usize],
    pub luma_log2_weight_denom: u8,
    pub delta_chroma_log2_weight_denom: i8,
    pub delta_luma_weight_l0: [i8; 15usize],
    pub luma_offset_l0: [i8; 15usize],
    pub delta_chroma_weight_l0: [[i8; 2usize]; 15usize],
    pub chroma_offset_l0: [[i8; 2usize]; 15usize],
    pub delta_luma_weight_l1: [i8; 15usize],
    pub luma_offset_l1: [i8; 15usize],
    pub delta_chroma_weight_l1: [[i8; 2usize]; 15usize],
    pub chroma_offset_l1: [[i8; 2usize]; 15usize],
    pub max_num_merge_cand: u8,
    pub slice_qp_delta: i8,
    pub slice_cb_qp_offset: i8,
    pub slice_cr_qp_offset: i8,
    pub slice_beta_offset_div2: i8,
    pub slice_tc_offset_div2: i8,
    pub slice_fields: _VAEncSliceParameterBufferHEVC__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSliceParameterBufferHEVC__bindgen_ty_1 {
    pub bits: __BindgenUnionField<_VAEncSliceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1>,
    pub value: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSliceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__VAEncSliceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncSliceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncSliceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncSliceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAEncSliceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn last_slice_of_pic_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_last_slice_of_pic_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn dependent_slice_segment_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_dependent_slice_segment_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn colour_plane_id(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (12usize as u16)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_colour_plane_id(&mut self, val: u32) {
        self._bitfield_1 &= !(12usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 2u32) & (12usize as u16);
    }
    #[inline]
    pub fn slice_temporal_mvp_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_slice_temporal_mvp_enabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn slice_sao_luma_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32usize as u16)) >>
                                       5u32) as u32)
        }
    }
    #[inline]
    pub fn set_slice_sao_luma_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(32usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 5u32) & (32usize as u16);
    }
    #[inline]
    pub fn slice_sao_chroma_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (64usize as u16)) >>
                                       6u32) as u32)
        }
    }
    #[inline]
    pub fn set_slice_sao_chroma_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(64usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 6u32) & (64usize as u16);
    }
    #[inline]
    pub fn num_ref_idx_active_override_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (128usize as u16)) >>
                                       7u32) as u32)
        }
    }
    #[inline]
    pub fn set_num_ref_idx_active_override_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(128usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 7u32) & (128usize as u16);
    }
    #[inline]
    pub fn mvd_l1_zero_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (256usize as u16)) >>
                                       8u32) as u32)
        }
    }
    #[inline]
    pub fn set_mvd_l1_zero_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(256usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 8u32) & (256usize as u16);
    }
    #[inline]
    pub fn cabac_init_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (512usize as u16)) >>
                                       9u32) as u32)
        }
    }
    #[inline]
    pub fn set_cabac_init_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(512usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 9u32) & (512usize as u16);
    }
    #[inline]
    pub fn slice_deblocking_filter_disabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (3072usize as u16)) >>
                                       10u32) as u32)
        }
    }
    #[inline]
    pub fn set_slice_deblocking_filter_disabled_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(3072usize as u16);
        self._bitfield_1 |=
            ((val as u32 as u16) << 10u32) & (3072usize as u16);
    }
    #[inline]
    pub fn slice_loop_filter_across_slices_enabled_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4096usize as u16)) >>
                                       12u32) as u32)
        }
    }
    #[inline]
    pub fn set_slice_loop_filter_across_slices_enabled_flag(&mut self,
                                                            val: u32) {
        self._bitfield_1 &= !(4096usize as u16);
        self._bitfield_1 |=
            ((val as u32 as u16) << 12u32) & (4096usize as u16);
    }
    #[inline]
    pub fn collocated_from_l0_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8192usize as u16)) >>
                                       13u32) as u32)
        }
    }
    #[inline]
    pub fn set_collocated_from_l0_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(8192usize as u16);
        self._bitfield_1 |=
            ((val as u32 as u16) << 13u32) & (8192usize as u16);
    }
}
#[test]
fn bindgen_test_layout__VAEncSliceParameterBufferHEVC__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncSliceParameterBufferHEVC__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncSliceParameterBufferHEVC__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncSliceParameterBufferHEVC__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VAEncSliceParameterBufferHEVC() {
    assert_eq!(::std::mem::size_of::<_VAEncSliceParameterBufferHEVC>() ,
               564usize);
    assert_eq!(::std::mem::align_of::<_VAEncSliceParameterBufferHEVC>() ,
               4usize);
}
impl Clone for _VAEncSliceParameterBufferHEVC {
    fn clone(&self) -> Self { *self }
}
pub type VAEncSliceParameterBufferHEVC = _VAEncSliceParameterBufferHEVC;
#[repr(C)]
#[derive(Copy)]
pub struct _VAQMatrixBufferHEVC {
    pub scaling_lists_4x4: [[[u8; 16usize]; 2usize]; 3usize],
    pub scaling_lists_8x8: [[[u8; 64usize]; 2usize]; 3usize],
    pub scaling_lists_16x16: [[[u8; 64usize]; 2usize]; 3usize],
    pub scaling_lists_32x32: [[u8; 64usize]; 2usize],
    pub scaling_list_dc_16x16: [[u8; 2usize]; 3usize],
    pub scaling_list_dc_32x32: [u8; 2usize],
}
#[test]
fn bindgen_test_layout__VAQMatrixBufferHEVC() {
    assert_eq!(::std::mem::size_of::<_VAQMatrixBufferHEVC>() , 1000usize);
    assert_eq!(::std::mem::align_of::<_VAQMatrixBufferHEVC>() , 1usize);
}
impl Clone for _VAQMatrixBufferHEVC {
    fn clone(&self) -> Self { *self }
}
pub type VAQMatrixBufferHEVC = _VAQMatrixBufferHEVC;
pub const VAEncPackedHeaderH264_SPS: _bindgen_ty_18 =
    _bindgen_ty_18::VAEncPackedHeaderH264_SPS;
pub const VAEncPackedHeaderH264_PPS: _bindgen_ty_18 =
    _bindgen_ty_18::VAEncPackedHeaderH264_PPS;
pub const VAEncPackedHeaderH264_Slice: _bindgen_ty_18 =
    _bindgen_ty_18::VAEncPackedHeaderH264_Slice;
pub const VAEncPackedHeaderH264_SEI: _bindgen_ty_18 =
    _bindgen_ty_18::VAEncPackedHeaderH264_SEI;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_18 {
    VAEncPackedHeaderH264_SPS = 1,
    VAEncPackedHeaderH264_PPS = 2,
    VAEncPackedHeaderH264_Slice = 3,
    VAEncPackedHeaderH264_SEI = 2147483649,
}
pub use self::_bindgen_ty_18 as VAEncPackedHeaderTypeH264;
#[repr(C)]
pub struct _VAEncSequenceParameterBufferH264 {
    pub seq_parameter_set_id: ::std::os::raw::c_uchar,
    pub level_idc: ::std::os::raw::c_uchar,
    pub intra_period: ::std::os::raw::c_uint,
    pub intra_idr_period: ::std::os::raw::c_uint,
    pub ip_period: ::std::os::raw::c_uint,
    pub bits_per_second: ::std::os::raw::c_uint,
    pub max_num_ref_frames: ::std::os::raw::c_uint,
    pub picture_width_in_mbs: ::std::os::raw::c_ushort,
    pub picture_height_in_mbs: ::std::os::raw::c_ushort,
    pub seq_fields: _VAEncSequenceParameterBufferH264__bindgen_ty_1,
    pub bit_depth_luma_minus8: ::std::os::raw::c_uchar,
    pub bit_depth_chroma_minus8: ::std::os::raw::c_uchar,
    pub num_ref_frames_in_pic_order_cnt_cycle: ::std::os::raw::c_uchar,
    pub offset_for_non_ref_pic: ::std::os::raw::c_int,
    pub offset_for_top_to_bottom_field: ::std::os::raw::c_int,
    pub offset_for_ref_frame: [::std::os::raw::c_int; 256usize],
    pub frame_cropping_flag: ::std::os::raw::c_uchar,
    pub frame_crop_left_offset: ::std::os::raw::c_uint,
    pub frame_crop_right_offset: ::std::os::raw::c_uint,
    pub frame_crop_top_offset: ::std::os::raw::c_uint,
    pub frame_crop_bottom_offset: ::std::os::raw::c_uint,
    pub vui_parameters_present_flag: ::std::os::raw::c_uchar,
    pub vui_fields: _VAEncSequenceParameterBufferH264__bindgen_ty_2,
    pub aspect_ratio_idc: ::std::os::raw::c_uchar,
    pub sar_width: ::std::os::raw::c_uint,
    pub sar_height: ::std::os::raw::c_uint,
    pub num_units_in_tick: ::std::os::raw::c_uint,
    pub time_scale: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSequenceParameterBufferH264__bindgen_ty_1 {
    pub bits: __BindgenUnionField<_VAEncSequenceParameterBufferH264__bindgen_ty_1__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSequenceParameterBufferH264__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__VAEncSequenceParameterBufferH264__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncSequenceParameterBufferH264__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncSequenceParameterBufferH264__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncSequenceParameterBufferH264__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAEncSequenceParameterBufferH264__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn chroma_format_idc(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (3usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_chroma_format_idc(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(3usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (3usize as u32);
    }
    #[inline]
    pub fn frame_mbs_only_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_frame_mbs_only_flag(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn mb_adaptive_frame_field_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                       3u32) as u32)
        }
    }
    #[inline]
    pub fn set_mb_adaptive_frame_field_flag(&mut self,
                                            val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn seq_scaling_matrix_present_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_seq_scaling_matrix_present_flag(&mut self,
                                               val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn direct_8x8_inference_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                       5u32) as u32)
        }
    }
    #[inline]
    pub fn set_direct_8x8_inference_flag(&mut self,
                                         val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn log2_max_frame_num_minus4(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (960usize as u32)) >>
                                       6u32) as u32)
        }
    }
    #[inline]
    pub fn set_log2_max_frame_num_minus4(&mut self,
                                         val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(960usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (960usize as u32);
    }
    #[inline]
    pub fn pic_order_cnt_type(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (3072usize as u32)) >>
                                       10u32) as u32)
        }
    }
    #[inline]
    pub fn set_pic_order_cnt_type(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(3072usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 10u32) & (3072usize as u32);
    }
    #[inline]
    pub fn log2_max_pic_order_cnt_lsb_minus4(&self)
     -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (61440usize as u32)) >>
                                       12u32) as u32)
        }
    }
    #[inline]
    pub fn set_log2_max_pic_order_cnt_lsb_minus4(&mut self,
                                                 val:
                                                     ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(61440usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (61440usize as u32);
    }
    #[inline]
    pub fn delta_pic_order_always_zero_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (65536usize as u32)) >>
                                       16u32) as u32)
        }
    }
    #[inline]
    pub fn set_delta_pic_order_always_zero_flag(&mut self,
                                                val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(65536usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (65536usize as u32);
    }
}
#[test]
fn bindgen_test_layout__VAEncSequenceParameterBufferH264__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncSequenceParameterBufferH264__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncSequenceParameterBufferH264__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncSequenceParameterBufferH264__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSequenceParameterBufferH264__bindgen_ty_2 {
    pub bits: __BindgenUnionField<_VAEncSequenceParameterBufferH264__bindgen_ty_2__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSequenceParameterBufferH264__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__VAEncSequenceParameterBufferH264__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncSequenceParameterBufferH264__bindgen_ty_2__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncSequenceParameterBufferH264__bindgen_ty_2__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncSequenceParameterBufferH264__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAEncSequenceParameterBufferH264__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn aspect_ratio_info_present_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_aspect_ratio_info_present_flag(&mut self,
                                              val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn timing_info_present_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_timing_info_present_flag(&mut self,
                                        val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn bitstream_restriction_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4usize as u16)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_bitstream_restriction_flag(&mut self,
                                          val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 2u32) & (4usize as u16);
    }
    #[inline]
    pub fn log2_max_mv_length_horizontal(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (248usize as u16)) >>
                                       3u32) as u32)
        }
    }
    #[inline]
    pub fn set_log2_max_mv_length_horizontal(&mut self,
                                             val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(248usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 3u32) & (248usize as u16);
    }
    #[inline]
    pub fn log2_max_mv_length_vertical(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (7936usize as u16)) >>
                                       8u32) as u32)
        }
    }
    #[inline]
    pub fn set_log2_max_mv_length_vertical(&mut self,
                                           val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(7936usize as u16);
        self._bitfield_1 |=
            ((val as u32 as u16) << 8u32) & (7936usize as u16);
    }
}
#[test]
fn bindgen_test_layout__VAEncSequenceParameterBufferH264__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<_VAEncSequenceParameterBufferH264__bindgen_ty_2>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncSequenceParameterBufferH264__bindgen_ty_2>()
               , 4usize);
}
impl Clone for _VAEncSequenceParameterBufferH264__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VAEncSequenceParameterBufferH264() {
    assert_eq!(::std::mem::size_of::<_VAEncSequenceParameterBufferH264>() ,
               1116usize);
    assert_eq!(::std::mem::align_of::<_VAEncSequenceParameterBufferH264>() ,
               4usize);
}
pub type VAEncSequenceParameterBufferH264 = _VAEncSequenceParameterBufferH264;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncPictureParameterBufferH264 {
    pub CurrPic: VAPictureH264,
    pub ReferenceFrames: [VAPictureH264; 16usize],
    pub coded_buf: VABufferID,
    pub pic_parameter_set_id: ::std::os::raw::c_uchar,
    pub seq_parameter_set_id: ::std::os::raw::c_uchar,
    pub last_picture: ::std::os::raw::c_uchar,
    pub frame_num: ::std::os::raw::c_ushort,
    pub pic_init_qp: ::std::os::raw::c_uchar,
    pub num_ref_idx_l0_active_minus1: ::std::os::raw::c_uchar,
    pub num_ref_idx_l1_active_minus1: ::std::os::raw::c_uchar,
    pub chroma_qp_index_offset: ::std::os::raw::c_char,
    pub second_chroma_qp_index_offset: ::std::os::raw::c_char,
    pub pic_fields: _VAEncPictureParameterBufferH264__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncPictureParameterBufferH264__bindgen_ty_1 {
    pub bits: __BindgenUnionField<_VAEncPictureParameterBufferH264__bindgen_ty_1__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncPictureParameterBufferH264__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__VAEncPictureParameterBufferH264__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncPictureParameterBufferH264__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncPictureParameterBufferH264__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncPictureParameterBufferH264__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAEncPictureParameterBufferH264__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn idr_pic_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_idr_pic_flag(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn reference_pic_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (6usize as u16)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_reference_pic_flag(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(6usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 1u32) & (6usize as u16);
    }
    #[inline]
    pub fn entropy_coding_mode_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8usize as u16)) >>
                                       3u32) as u32)
        }
    }
    #[inline]
    pub fn set_entropy_coding_mode_flag(&mut self,
                                        val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(8usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 3u32) & (8usize as u16);
    }
    #[inline]
    pub fn weighted_pred_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_weighted_pred_flag(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn weighted_bipred_idc(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (96usize as u16)) >>
                                       5u32) as u32)
        }
    }
    #[inline]
    pub fn set_weighted_bipred_idc(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(96usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 5u32) & (96usize as u16);
    }
    #[inline]
    pub fn constrained_intra_pred_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (128usize as u16)) >>
                                       7u32) as u32)
        }
    }
    #[inline]
    pub fn set_constrained_intra_pred_flag(&mut self,
                                           val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(128usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 7u32) & (128usize as u16);
    }
    #[inline]
    pub fn transform_8x8_mode_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (256usize as u16)) >>
                                       8u32) as u32)
        }
    }
    #[inline]
    pub fn set_transform_8x8_mode_flag(&mut self,
                                       val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(256usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 8u32) & (256usize as u16);
    }
    #[inline]
    pub fn deblocking_filter_control_present_flag(&self)
     -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (512usize as u16)) >>
                                       9u32) as u32)
        }
    }
    #[inline]
    pub fn set_deblocking_filter_control_present_flag(&mut self,
                                                      val:
                                                          ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(512usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 9u32) & (512usize as u16);
    }
    #[inline]
    pub fn redundant_pic_cnt_present_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1024usize as u16)) >>
                                       10u32) as u32)
        }
    }
    #[inline]
    pub fn set_redundant_pic_cnt_present_flag(&mut self,
                                              val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1024usize as u16);
        self._bitfield_1 |=
            ((val as u32 as u16) << 10u32) & (1024usize as u16);
    }
    #[inline]
    pub fn pic_order_present_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2048usize as u16)) >>
                                       11u32) as u32)
        }
    }
    #[inline]
    pub fn set_pic_order_present_flag(&mut self,
                                      val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(2048usize as u16);
        self._bitfield_1 |=
            ((val as u32 as u16) << 11u32) & (2048usize as u16);
    }
    #[inline]
    pub fn pic_scaling_matrix_present_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4096usize as u16)) >>
                                       12u32) as u32)
        }
    }
    #[inline]
    pub fn set_pic_scaling_matrix_present_flag(&mut self,
                                               val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4096usize as u16);
        self._bitfield_1 |=
            ((val as u32 as u16) << 12u32) & (4096usize as u16);
    }
}
#[test]
fn bindgen_test_layout__VAEncPictureParameterBufferH264__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncPictureParameterBufferH264__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncPictureParameterBufferH264__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncPictureParameterBufferH264__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VAEncPictureParameterBufferH264() {
    assert_eq!(::std::mem::size_of::<_VAEncPictureParameterBufferH264>() ,
               360usize);
    assert_eq!(::std::mem::align_of::<_VAEncPictureParameterBufferH264>() ,
               4usize);
}
impl Clone for _VAEncPictureParameterBufferH264 {
    fn clone(&self) -> Self { *self }
}
pub type VAEncPictureParameterBufferH264 = _VAEncPictureParameterBufferH264;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSliceParameterBufferH264 {
    pub macroblock_address: ::std::os::raw::c_uint,
    pub num_macroblocks: ::std::os::raw::c_uint,
    pub macroblock_info: VABufferID,
    pub slice_type: ::std::os::raw::c_uchar,
    pub pic_parameter_set_id: ::std::os::raw::c_uchar,
    pub idr_pic_id: ::std::os::raw::c_ushort,
    pub pic_order_cnt_lsb: ::std::os::raw::c_ushort,
    pub delta_pic_order_cnt_bottom: ::std::os::raw::c_int,
    pub delta_pic_order_cnt: [::std::os::raw::c_int; 2usize],
    pub direct_spatial_mv_pred_flag: ::std::os::raw::c_uchar,
    pub num_ref_idx_active_override_flag: ::std::os::raw::c_uchar,
    pub num_ref_idx_l0_active_minus1: ::std::os::raw::c_uchar,
    pub num_ref_idx_l1_active_minus1: ::std::os::raw::c_uchar,
    pub RefPicList0: [VAPictureH264; 32usize],
    pub RefPicList1: [VAPictureH264; 32usize],
    pub luma_log2_weight_denom: ::std::os::raw::c_uchar,
    pub chroma_log2_weight_denom: ::std::os::raw::c_uchar,
    pub luma_weight_l0_flag: ::std::os::raw::c_uchar,
    pub luma_weight_l0: [::std::os::raw::c_short; 32usize],
    pub luma_offset_l0: [::std::os::raw::c_short; 32usize],
    pub chroma_weight_l0_flag: ::std::os::raw::c_uchar,
    pub chroma_weight_l0: [[::std::os::raw::c_short; 2usize]; 32usize],
    pub chroma_offset_l0: [[::std::os::raw::c_short; 2usize]; 32usize],
    pub luma_weight_l1_flag: ::std::os::raw::c_uchar,
    pub luma_weight_l1: [::std::os::raw::c_short; 32usize],
    pub luma_offset_l1: [::std::os::raw::c_short; 32usize],
    pub chroma_weight_l1_flag: ::std::os::raw::c_uchar,
    pub chroma_weight_l1: [[::std::os::raw::c_short; 2usize]; 32usize],
    pub chroma_offset_l1: [[::std::os::raw::c_short; 2usize]; 32usize],
    pub cabac_init_idc: ::std::os::raw::c_uchar,
    pub slice_qp_delta: ::std::os::raw::c_char,
    pub disable_deblocking_filter_idc: ::std::os::raw::c_uchar,
    pub slice_alpha_c0_offset_div2: ::std::os::raw::c_char,
    pub slice_beta_offset_div2: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__VAEncSliceParameterBufferH264() {
    assert_eq!(::std::mem::size_of::<_VAEncSliceParameterBufferH264>() ,
               2100usize);
    assert_eq!(::std::mem::align_of::<_VAEncSliceParameterBufferH264>() ,
               4usize);
}
impl Clone for _VAEncSliceParameterBufferH264 {
    fn clone(&self) -> Self { *self }
}
pub type VAEncSliceParameterBufferH264 = _VAEncSliceParameterBufferH264;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncMacroblockParameterBufferH264 {
    pub qp: ::std::os::raw::c_uchar,
    pub info: _VAEncMacroblockParameterBufferH264__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncMacroblockParameterBufferH264__bindgen_ty_1 {
    pub intra_fields: __BindgenUnionField<_VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_1>,
    pub inter_fields: __BindgenUnionField<_VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_1 {
    pub bits: _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub value: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u16,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout__VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for
 _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
 {
    fn clone(&self) -> Self { *self }
}
impl _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
 {
    #[inline]
    pub fn pred_avail_override_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_pred_avail_override_flag(&mut self,
                                        val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn pred_avail_flags(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (510usize as u16)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_pred_avail_flags(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(510usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 1u32) & (510usize as u16);
    }
}
#[test]
fn bindgen_test_layout__VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<_VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_1
 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_2 {
    pub bits: _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub value: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub bindgen_union_field: [u8; 0usize],
    pub _address: u8,
}
#[test]
fn bindgen_test_layout__VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()
               , 0usize);
    assert_eq!(::std::mem::align_of::<_VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()
               , 1usize);
}
impl Clone for
 _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1
 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<_VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_2>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_2>()
               , 4usize);
}
impl Clone for _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_2
 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VAEncMacroblockParameterBufferH264__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncMacroblockParameterBufferH264__bindgen_ty_1>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<_VAEncMacroblockParameterBufferH264__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncMacroblockParameterBufferH264__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VAEncMacroblockParameterBufferH264() {
    assert_eq!(::std::mem::size_of::<_VAEncMacroblockParameterBufferH264>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<_VAEncMacroblockParameterBufferH264>() ,
               4usize);
}
impl Clone for _VAEncMacroblockParameterBufferH264 {
    fn clone(&self) -> Self { *self }
}
pub type VAEncMacroblockParameterBufferH264 =
    _VAEncMacroblockParameterBufferH264;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncPictureParameterBufferJPEG {
    pub reconstructed_picture: VASurfaceID,
    pub picture_width: ::std::os::raw::c_ushort,
    pub picture_height: ::std::os::raw::c_ushort,
    pub coded_buf: VABufferID,
    pub pic_flags: _VAEncPictureParameterBufferJPEG__bindgen_ty_1,
    pub sample_bit_depth: ::std::os::raw::c_uchar,
    pub num_scan: ::std::os::raw::c_uchar,
    pub num_components: ::std::os::raw::c_ushort,
    pub component_id: [::std::os::raw::c_uchar; 4usize],
    pub quantiser_table_selector: [::std::os::raw::c_uchar; 4usize],
    pub quality: ::std::os::raw::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncPictureParameterBufferJPEG__bindgen_ty_1 {
    pub bits: __BindgenUnionField<_VAEncPictureParameterBufferJPEG__bindgen_ty_1__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncPictureParameterBufferJPEG__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout__VAEncPictureParameterBufferJPEG__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncPictureParameterBufferJPEG__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncPictureParameterBufferJPEG__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncPictureParameterBufferJPEG__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAEncPictureParameterBufferJPEG__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn profile(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (3usize as u8)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_profile(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(3usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 0u32) & (3usize as u8);
    }
    #[inline]
    pub fn progressive(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4usize as u8)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_progressive(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 2u32) & (4usize as u8);
    }
    #[inline]
    pub fn huffman(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8usize as u8)) >>
                                       3u32) as u32)
        }
    }
    #[inline]
    pub fn set_huffman(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(8usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 3u32) & (8usize as u8);
    }
    #[inline]
    pub fn interleaved(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u8)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_interleaved(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(16usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 4u32) & (16usize as u8);
    }
    #[inline]
    pub fn differential(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32usize as u8)) >>
                                       5u32) as u32)
        }
    }
    #[inline]
    pub fn set_differential(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(32usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 5u32) & (32usize as u8);
    }
}
#[test]
fn bindgen_test_layout__VAEncPictureParameterBufferJPEG__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncPictureParameterBufferJPEG__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncPictureParameterBufferJPEG__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncPictureParameterBufferJPEG__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VAEncPictureParameterBufferJPEG() {
    assert_eq!(::std::mem::size_of::<_VAEncPictureParameterBufferJPEG>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<_VAEncPictureParameterBufferJPEG>() ,
               4usize);
}
impl Clone for _VAEncPictureParameterBufferJPEG {
    fn clone(&self) -> Self { *self }
}
pub type VAEncPictureParameterBufferJPEG = _VAEncPictureParameterBufferJPEG;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSliceParameterBufferJPEG {
    pub restart_interval: ::std::os::raw::c_ushort,
    pub num_components: ::std::os::raw::c_ushort,
    pub components: [_VAEncSliceParameterBufferJPEG__bindgen_ty_1; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSliceParameterBufferJPEG__bindgen_ty_1 {
    pub component_selector: ::std::os::raw::c_uchar,
    pub dc_table_selector: ::std::os::raw::c_uchar,
    pub ac_table_selector: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout__VAEncSliceParameterBufferJPEG__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncSliceParameterBufferJPEG__bindgen_ty_1>()
               , 3usize);
    assert_eq!(::std::mem::align_of::<_VAEncSliceParameterBufferJPEG__bindgen_ty_1>()
               , 1usize);
}
impl Clone for _VAEncSliceParameterBufferJPEG__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VAEncSliceParameterBufferJPEG() {
    assert_eq!(::std::mem::size_of::<_VAEncSliceParameterBufferJPEG>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<_VAEncSliceParameterBufferJPEG>() ,
               2usize);
}
impl Clone for _VAEncSliceParameterBufferJPEG {
    fn clone(&self) -> Self { *self }
}
pub type VAEncSliceParameterBufferJPEG = _VAEncSliceParameterBufferJPEG;
#[repr(C)]
pub struct _VAQMatrixBufferJPEG {
    pub load_lum_quantiser_matrix: ::std::os::raw::c_int,
    pub load_chroma_quantiser_matrix: ::std::os::raw::c_int,
    pub lum_quantiser_matrix: [::std::os::raw::c_uchar; 64usize],
    pub chroma_quantiser_matrix: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout__VAQMatrixBufferJPEG() {
    assert_eq!(::std::mem::size_of::<_VAQMatrixBufferJPEG>() , 136usize);
    assert_eq!(::std::mem::align_of::<_VAQMatrixBufferJPEG>() , 4usize);
}
pub type VAQMatrixBufferJPEG = _VAQMatrixBufferJPEG;
pub type VAQMatrixBufferMPEG2 = VAIQMatrixBufferMPEG2;
pub const VAEncPackedHeaderMPEG2_SPS: _bindgen_ty_19 =
    _bindgen_ty_19::VAEncPackedHeaderMPEG2_SPS;
pub const VAEncPackedHeaderMPEG2_PPS: _bindgen_ty_19 =
    _bindgen_ty_19::VAEncPackedHeaderMPEG2_PPS;
pub const VAEncPackedHeaderMPEG2_Slice: _bindgen_ty_19 =
    _bindgen_ty_19::VAEncPackedHeaderMPEG2_Slice;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_19 {
    VAEncPackedHeaderMPEG2_SPS = 1,
    VAEncPackedHeaderMPEG2_PPS = 2,
    VAEncPackedHeaderMPEG2_Slice = 3,
}
pub use self::_bindgen_ty_19 as VAEncPackedHeaderTypeMPEG2;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSequenceParameterBufferMPEG2 {
    pub intra_period: ::std::os::raw::c_uint,
    pub ip_period: ::std::os::raw::c_uint,
    pub picture_width: ::std::os::raw::c_ushort,
    pub picture_height: ::std::os::raw::c_ushort,
    pub bits_per_second: ::std::os::raw::c_uint,
    pub frame_rate: f32,
    pub aspect_ratio_information: ::std::os::raw::c_ushort,
    pub vbv_buffer_size: ::std::os::raw::c_uint,
    pub sequence_extension: _VAEncSequenceParameterBufferMPEG2__bindgen_ty_1,
    pub new_gop_header: ::std::os::raw::c_uint,
    pub gop_header: _VAEncSequenceParameterBufferMPEG2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSequenceParameterBufferMPEG2__bindgen_ty_1 {
    pub bits: __BindgenUnionField<_VAEncSequenceParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSequenceParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__VAEncSequenceParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncSequenceParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncSequenceParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncSequenceParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1
 {
    fn clone(&self) -> Self { *self }
}
impl _VAEncSequenceParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn profile_and_level_indication(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (255usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_profile_and_level_indication(&mut self,
                                            val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(255usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (255usize as u32);
    }
    #[inline]
    pub fn progressive_sequence(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (256usize as u32)) >>
                                       8u32) as u32)
        }
    }
    #[inline]
    pub fn set_progressive_sequence(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(256usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 8u32) & (256usize as u32);
    }
    #[inline]
    pub fn chroma_format(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1536usize as u32)) >>
                                       9u32) as u32)
        }
    }
    #[inline]
    pub fn set_chroma_format(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1536usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 9u32) & (1536usize as u32);
    }
    #[inline]
    pub fn low_delay(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2048usize as u32)) >>
                                       11u32) as u32)
        }
    }
    #[inline]
    pub fn set_low_delay(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(2048usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 11u32) & (2048usize as u32);
    }
    #[inline]
    pub fn frame_rate_extension_n(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (12288usize as u32)) >>
                                       12u32) as u32)
        }
    }
    #[inline]
    pub fn set_frame_rate_extension_n(&mut self,
                                      val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(12288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (12288usize as u32);
    }
    #[inline]
    pub fn frame_rate_extension_d(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (507904usize as u32))
                                       >> 14u32) as u32)
        }
    }
    #[inline]
    pub fn set_frame_rate_extension_d(&mut self,
                                      val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(507904usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (507904usize as u32);
    }
}
#[test]
fn bindgen_test_layout__VAEncSequenceParameterBufferMPEG2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncSequenceParameterBufferMPEG2__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncSequenceParameterBufferMPEG2__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncSequenceParameterBufferMPEG2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSequenceParameterBufferMPEG2__bindgen_ty_2 {
    pub bits: __BindgenUnionField<_VAEncSequenceParameterBufferMPEG2__bindgen_ty_2__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSequenceParameterBufferMPEG2__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__VAEncSequenceParameterBufferMPEG2__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncSequenceParameterBufferMPEG2__bindgen_ty_2__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncSequenceParameterBufferMPEG2__bindgen_ty_2__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncSequenceParameterBufferMPEG2__bindgen_ty_2__bindgen_ty_1
 {
    fn clone(&self) -> Self { *self }
}
impl _VAEncSequenceParameterBufferMPEG2__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn time_code(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (33554431usize as u32))
                                       >> 0u32) as u32)
        }
    }
    #[inline]
    pub fn set_time_code(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(33554431usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 0u32) & (33554431usize as u32);
    }
    #[inline]
    pub fn closed_gop(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (33554432usize as u32))
                                       >> 25u32) as u32)
        }
    }
    #[inline]
    pub fn set_closed_gop(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(33554432usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 25u32) & (33554432usize as u32);
    }
    #[inline]
    pub fn broken_link(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (67108864usize as u32))
                                       >> 26u32) as u32)
        }
    }
    #[inline]
    pub fn set_broken_link(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(67108864usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 26u32) & (67108864usize as u32);
    }
}
#[test]
fn bindgen_test_layout__VAEncSequenceParameterBufferMPEG2__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<_VAEncSequenceParameterBufferMPEG2__bindgen_ty_2>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncSequenceParameterBufferMPEG2__bindgen_ty_2>()
               , 4usize);
}
impl Clone for _VAEncSequenceParameterBufferMPEG2__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VAEncSequenceParameterBufferMPEG2() {
    assert_eq!(::std::mem::size_of::<_VAEncSequenceParameterBufferMPEG2>() ,
               40usize);
    assert_eq!(::std::mem::align_of::<_VAEncSequenceParameterBufferMPEG2>() ,
               4usize);
}
impl Clone for _VAEncSequenceParameterBufferMPEG2 {
    fn clone(&self) -> Self { *self }
}
pub type VAEncSequenceParameterBufferMPEG2 =
    _VAEncSequenceParameterBufferMPEG2;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncPictureParameterBufferMPEG2 {
    pub forward_reference_picture: VASurfaceID,
    pub backward_reference_picture: VASurfaceID,
    pub reconstructed_picture: VASurfaceID,
    pub coded_buf: VABufferID,
    pub last_picture: ::std::os::raw::c_uchar,
    pub picture_type: VAEncPictureType,
    pub temporal_reference: ::std::os::raw::c_uint,
    pub vbv_delay: ::std::os::raw::c_uint,
    pub f_code: [[::std::os::raw::c_uchar; 2usize]; 2usize],
    pub picture_coding_extension: _VAEncPictureParameterBufferMPEG2__bindgen_ty_1,
    pub composite_display: _VAEncPictureParameterBufferMPEG2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncPictureParameterBufferMPEG2__bindgen_ty_1 {
    pub bits: __BindgenUnionField<_VAEncPictureParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncPictureParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout__VAEncPictureParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncPictureParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncPictureParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncPictureParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAEncPictureParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn intra_dc_precision(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (3usize as u16)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_intra_dc_precision(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(3usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 0u32) & (3usize as u16);
    }
    #[inline]
    pub fn picture_structure(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (12usize as u16)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_picture_structure(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(12usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 2u32) & (12usize as u16);
    }
    #[inline]
    pub fn top_field_first(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_top_field_first(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn frame_pred_frame_dct(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32usize as u16)) >>
                                       5u32) as u32)
        }
    }
    #[inline]
    pub fn set_frame_pred_frame_dct(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(32usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 5u32) & (32usize as u16);
    }
    #[inline]
    pub fn concealment_motion_vectors(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (64usize as u16)) >>
                                       6u32) as u32)
        }
    }
    #[inline]
    pub fn set_concealment_motion_vectors(&mut self,
                                          val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(64usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 6u32) & (64usize as u16);
    }
    #[inline]
    pub fn q_scale_type(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (128usize as u16)) >>
                                       7u32) as u32)
        }
    }
    #[inline]
    pub fn set_q_scale_type(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(128usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 7u32) & (128usize as u16);
    }
    #[inline]
    pub fn intra_vlc_format(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (256usize as u16)) >>
                                       8u32) as u32)
        }
    }
    #[inline]
    pub fn set_intra_vlc_format(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(256usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 8u32) & (256usize as u16);
    }
    #[inline]
    pub fn alternate_scan(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (512usize as u16)) >>
                                       9u32) as u32)
        }
    }
    #[inline]
    pub fn set_alternate_scan(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(512usize as u16);
        self._bitfield_1 |= ((val as u32 as u16) << 9u32) & (512usize as u16);
    }
    #[inline]
    pub fn repeat_first_field(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1024usize as u16)) >>
                                       10u32) as u32)
        }
    }
    #[inline]
    pub fn set_repeat_first_field(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1024usize as u16);
        self._bitfield_1 |=
            ((val as u32 as u16) << 10u32) & (1024usize as u16);
    }
    #[inline]
    pub fn progressive_frame(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2048usize as u16)) >>
                                       11u32) as u32)
        }
    }
    #[inline]
    pub fn set_progressive_frame(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(2048usize as u16);
        self._bitfield_1 |=
            ((val as u32 as u16) << 11u32) & (2048usize as u16);
    }
    #[inline]
    pub fn composite_display_flag(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4096usize as u16)) >>
                                       12u32) as u32)
        }
    }
    #[inline]
    pub fn set_composite_display_flag(&mut self,
                                      val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4096usize as u16);
        self._bitfield_1 |=
            ((val as u32 as u16) << 12u32) & (4096usize as u16);
    }
}
#[test]
fn bindgen_test_layout__VAEncPictureParameterBufferMPEG2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncPictureParameterBufferMPEG2__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncPictureParameterBufferMPEG2__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncPictureParameterBufferMPEG2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncPictureParameterBufferMPEG2__bindgen_ty_2 {
    pub bits: __BindgenUnionField<_VAEncPictureParameterBufferMPEG2__bindgen_ty_2__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncPictureParameterBufferMPEG2__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__VAEncPictureParameterBufferMPEG2__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncPictureParameterBufferMPEG2__bindgen_ty_2__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncPictureParameterBufferMPEG2__bindgen_ty_2__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncPictureParameterBufferMPEG2__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAEncPictureParameterBufferMPEG2__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn v_axis(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_v_axis(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn field_sequence(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (14usize as u32)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_field_sequence(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(14usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (14usize as u32);
    }
    #[inline]
    pub fn sub_carrier(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_sub_carrier(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn burst_amplitude(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4064usize as u32)) >>
                                       5u32) as u32)
        }
    }
    #[inline]
    pub fn set_burst_amplitude(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4064usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 5u32) & (4064usize as u32);
    }
    #[inline]
    pub fn sub_carrier_phase(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1044480usize as u32))
                                       >> 12u32) as u32)
        }
    }
    #[inline]
    pub fn set_sub_carrier_phase(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1044480usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (1044480usize as u32);
    }
}
#[test]
fn bindgen_test_layout__VAEncPictureParameterBufferMPEG2__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<_VAEncPictureParameterBufferMPEG2__bindgen_ty_2>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncPictureParameterBufferMPEG2__bindgen_ty_2>()
               , 4usize);
}
impl Clone for _VAEncPictureParameterBufferMPEG2__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VAEncPictureParameterBufferMPEG2() {
    assert_eq!(::std::mem::size_of::<_VAEncPictureParameterBufferMPEG2>() ,
               44usize);
    assert_eq!(::std::mem::align_of::<_VAEncPictureParameterBufferMPEG2>() ,
               4usize);
}
impl Clone for _VAEncPictureParameterBufferMPEG2 {
    fn clone(&self) -> Self { *self }
}
pub type VAEncPictureParameterBufferMPEG2 = _VAEncPictureParameterBufferMPEG2;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSliceParameterBufferMPEG2 {
    pub macroblock_address: ::std::os::raw::c_uint,
    pub num_macroblocks: ::std::os::raw::c_uint,
    pub quantiser_scale_code: ::std::os::raw::c_int,
    pub is_intra_slice: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__VAEncSliceParameterBufferMPEG2() {
    assert_eq!(::std::mem::size_of::<_VAEncSliceParameterBufferMPEG2>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<_VAEncSliceParameterBufferMPEG2>() ,
               4usize);
}
impl Clone for _VAEncSliceParameterBufferMPEG2 {
    fn clone(&self) -> Self { *self }
}
pub type VAEncSliceParameterBufferMPEG2 = _VAEncSliceParameterBufferMPEG2;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSequenceParameterBufferVP8 {
    pub frame_width: ::std::os::raw::c_uint,
    pub frame_height: ::std::os::raw::c_uint,
    pub frame_width_scale: ::std::os::raw::c_uint,
    pub frame_height_scale: ::std::os::raw::c_uint,
    pub error_resilient: ::std::os::raw::c_uint,
    pub kf_auto: ::std::os::raw::c_uint,
    pub kf_min_dist: ::std::os::raw::c_uint,
    pub kf_max_dist: ::std::os::raw::c_uint,
    pub bits_per_second: ::std::os::raw::c_uint,
    pub intra_period: ::std::os::raw::c_uint,
    pub reference_frames: [VASurfaceID; 4usize],
}
#[test]
fn bindgen_test_layout__VAEncSequenceParameterBufferVP8() {
    assert_eq!(::std::mem::size_of::<_VAEncSequenceParameterBufferVP8>() ,
               56usize);
    assert_eq!(::std::mem::align_of::<_VAEncSequenceParameterBufferVP8>() ,
               4usize);
}
impl Clone for _VAEncSequenceParameterBufferVP8 {
    fn clone(&self) -> Self { *self }
}
pub type VAEncSequenceParameterBufferVP8 = _VAEncSequenceParameterBufferVP8;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncPictureParameterBufferVP8 {
    pub reconstructed_frame: VASurfaceID,
    pub ref_last_frame: VASurfaceID,
    pub ref_gf_frame: VASurfaceID,
    pub ref_arf_frame: VASurfaceID,
    pub coded_buf: VABufferID,
    pub ref_flags: _VAEncPictureParameterBufferVP8__bindgen_ty_1,
    pub pic_flags: _VAEncPictureParameterBufferVP8__bindgen_ty_2,
    pub loop_filter_level: [::std::os::raw::c_char; 4usize],
    pub ref_lf_delta: [::std::os::raw::c_char; 4usize],
    pub mode_lf_delta: [::std::os::raw::c_char; 4usize],
    pub sharpness_level: ::std::os::raw::c_uchar,
    pub clamp_qindex_high: ::std::os::raw::c_uchar,
    pub clamp_qindex_low: ::std::os::raw::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncPictureParameterBufferVP8__bindgen_ty_1 {
    pub bits: __BindgenUnionField<_VAEncPictureParameterBufferVP8__bindgen_ty_1__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncPictureParameterBufferVP8__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__VAEncPictureParameterBufferVP8__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncPictureParameterBufferVP8__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncPictureParameterBufferVP8__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncPictureParameterBufferVP8__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAEncPictureParameterBufferVP8__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn force_kf(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_force_kf(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn no_ref_last(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_no_ref_last(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn no_ref_gf(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_no_ref_gf(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn no_ref_arf(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                       3u32) as u32)
        }
    }
    #[inline]
    pub fn set_no_ref_arf(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn reserved(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (4294967280usize as u32)) >> 4u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4294967280usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 4u32) & (4294967280usize as u32);
    }
}
#[test]
fn bindgen_test_layout__VAEncPictureParameterBufferVP8__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncPictureParameterBufferVP8__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncPictureParameterBufferVP8__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncPictureParameterBufferVP8__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncPictureParameterBufferVP8__bindgen_ty_2 {
    pub bits: __BindgenUnionField<_VAEncPictureParameterBufferVP8__bindgen_ty_2__bindgen_ty_1>,
    pub value: __BindgenUnionField<::std::os::raw::c_uint>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncPictureParameterBufferVP8__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__VAEncPictureParameterBufferVP8__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncPictureParameterBufferVP8__bindgen_ty_2__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncPictureParameterBufferVP8__bindgen_ty_2__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncPictureParameterBufferVP8__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAEncPictureParameterBufferVP8__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn frame_type(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_frame_type(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn version(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (14usize as u32)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_version(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(14usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (14usize as u32);
    }
    #[inline]
    pub fn show_frame(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_show_frame(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn color_space(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                       5u32) as u32)
        }
    }
    #[inline]
    pub fn set_color_space(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn recon_filter_type(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (192usize as u32)) >>
                                       6u32) as u32)
        }
    }
    #[inline]
    pub fn set_recon_filter_type(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(192usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 6u32) & (192usize as u32);
    }
    #[inline]
    pub fn loop_filter_type(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (768usize as u32)) >>
                                       8u32) as u32)
        }
    }
    #[inline]
    pub fn set_loop_filter_type(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(768usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 8u32) & (768usize as u32);
    }
    #[inline]
    pub fn auto_partitions(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1024usize as u32)) >>
                                       10u32) as u32)
        }
    }
    #[inline]
    pub fn set_auto_partitions(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1024usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 10u32) & (1024usize as u32);
    }
    #[inline]
    pub fn num_token_partitions(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (6144usize as u32)) >>
                                       11u32) as u32)
        }
    }
    #[inline]
    pub fn set_num_token_partitions(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(6144usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 11u32) & (6144usize as u32);
    }
    #[inline]
    pub fn clamping_type(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8192usize as u32)) >>
                                       13u32) as u32)
        }
    }
    #[inline]
    pub fn set_clamping_type(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(8192usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 13u32) & (8192usize as u32);
    }
    #[inline]
    pub fn segmentation_enabled(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16384usize as u32)) >>
                                       14u32) as u32)
        }
    }
    #[inline]
    pub fn set_segmentation_enabled(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(16384usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (16384usize as u32);
    }
    #[inline]
    pub fn update_mb_segmentation_map(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32768usize as u32)) >>
                                       15u32) as u32)
        }
    }
    #[inline]
    pub fn set_update_mb_segmentation_map(&mut self,
                                          val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(32768usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 15u32) & (32768usize as u32);
    }
    #[inline]
    pub fn update_segment_feature_data(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (65536usize as u32)) >>
                                       16u32) as u32)
        }
    }
    #[inline]
    pub fn set_update_segment_feature_data(&mut self,
                                           val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(65536usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (65536usize as u32);
    }
    #[inline]
    pub fn loop_filter_adj_enable(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (131072usize as u32))
                                       >> 17u32) as u32)
        }
    }
    #[inline]
    pub fn set_loop_filter_adj_enable(&mut self,
                                      val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(131072usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 17u32) & (131072usize as u32);
    }
    #[inline]
    pub fn refresh_entropy_probs(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (262144usize as u32))
                                       >> 18u32) as u32)
        }
    }
    #[inline]
    pub fn set_refresh_entropy_probs(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(262144usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 18u32) & (262144usize as u32);
    }
    #[inline]
    pub fn refresh_golden_frame(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (524288usize as u32))
                                       >> 19u32) as u32)
        }
    }
    #[inline]
    pub fn set_refresh_golden_frame(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(524288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 19u32) & (524288usize as u32);
    }
    #[inline]
    pub fn refresh_alternate_frame(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1048576usize as u32))
                                       >> 20u32) as u32)
        }
    }
    #[inline]
    pub fn set_refresh_alternate_frame(&mut self,
                                       val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(1048576usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 20u32) & (1048576usize as u32);
    }
    #[inline]
    pub fn refresh_last(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2097152usize as u32))
                                       >> 21u32) as u32)
        }
    }
    #[inline]
    pub fn set_refresh_last(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(2097152usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 21u32) & (2097152usize as u32);
    }
    #[inline]
    pub fn copy_buffer_to_golden(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (12582912usize as u32))
                                       >> 22u32) as u32)
        }
    }
    #[inline]
    pub fn set_copy_buffer_to_golden(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(12582912usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 22u32) & (12582912usize as u32);
    }
    #[inline]
    pub fn copy_buffer_to_alternate(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (50331648usize as u32))
                                       >> 24u32) as u32)
        }
    }
    #[inline]
    pub fn set_copy_buffer_to_alternate(&mut self,
                                        val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(50331648usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 24u32) & (50331648usize as u32);
    }
    #[inline]
    pub fn sign_bias_golden(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (67108864usize as u32))
                                       >> 26u32) as u32)
        }
    }
    #[inline]
    pub fn set_sign_bias_golden(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(67108864usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 26u32) & (67108864usize as u32);
    }
    #[inline]
    pub fn sign_bias_alternate(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (134217728usize as u32)) >> 27u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_sign_bias_alternate(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(134217728usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 27u32) & (134217728usize as u32);
    }
    #[inline]
    pub fn mb_no_coeff_skip(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (268435456usize as u32)) >> 28u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_mb_no_coeff_skip(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(268435456usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 28u32) & (268435456usize as u32);
    }
    #[inline]
    pub fn forced_lf_adjustment(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (536870912usize as u32)) >> 29u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_forced_lf_adjustment(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(536870912usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 29u32) & (536870912usize as u32);
    }
    #[inline]
    pub fn reserved(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (3221225472usize as u32)) >> 30u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(3221225472usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 30u32) & (3221225472usize as u32);
    }
}
#[test]
fn bindgen_test_layout__VAEncPictureParameterBufferVP8__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<_VAEncPictureParameterBufferVP8__bindgen_ty_2>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncPictureParameterBufferVP8__bindgen_ty_2>()
               , 4usize);
}
impl Clone for _VAEncPictureParameterBufferVP8__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VAEncPictureParameterBufferVP8() {
    assert_eq!(::std::mem::size_of::<_VAEncPictureParameterBufferVP8>() ,
               44usize);
    assert_eq!(::std::mem::align_of::<_VAEncPictureParameterBufferVP8>() ,
               4usize);
}
impl Clone for _VAEncPictureParameterBufferVP8 {
    fn clone(&self) -> Self { *self }
}
pub type VAEncPictureParameterBufferVP8 = _VAEncPictureParameterBufferVP8;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncMBMapBufferVP8 {
    pub num_mbs: ::std::os::raw::c_uint,
    pub mb_segment_id: *mut ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout__VAEncMBMapBufferVP8() {
    assert_eq!(::std::mem::size_of::<_VAEncMBMapBufferVP8>() , 16usize);
    assert_eq!(::std::mem::align_of::<_VAEncMBMapBufferVP8>() , 8usize);
}
impl Clone for _VAEncMBMapBufferVP8 {
    fn clone(&self) -> Self { *self }
}
pub type VAEncMBMapBufferVP8 = _VAEncMBMapBufferVP8;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAQMatrixBufferVP8 {
    pub quantization_index: [::std::os::raw::c_ushort; 4usize],
    pub quantization_index_delta: [::std::os::raw::c_short; 5usize],
}
#[test]
fn bindgen_test_layout__VAQMatrixBufferVP8() {
    assert_eq!(::std::mem::size_of::<_VAQMatrixBufferVP8>() , 18usize);
    assert_eq!(::std::mem::align_of::<_VAQMatrixBufferVP8>() , 2usize);
}
impl Clone for _VAQMatrixBufferVP8 {
    fn clone(&self) -> Self { *self }
}
pub type VAQMatrixBufferVP8 = _VAQMatrixBufferVP8;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VACodedBufferVP9Status {
    pub base_qp_index: u16,
    pub loop_filter_level: u8,
    pub long_term_indication: u8,
    pub next_frame_width: u16,
    pub next_frame_height: u16,
}
#[test]
fn bindgen_test_layout__VACodedBufferVP9Status() {
    assert_eq!(::std::mem::size_of::<_VACodedBufferVP9Status>() , 8usize);
    assert_eq!(::std::mem::align_of::<_VACodedBufferVP9Status>() , 2usize);
}
impl Clone for _VACodedBufferVP9Status {
    fn clone(&self) -> Self { *self }
}
pub type VACodedBufferVP9Status = _VACodedBufferVP9Status;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSequenceParameterBufferVP9 {
    pub max_frame_width: u32,
    pub max_frame_height: u32,
    pub kf_auto: u32,
    pub kf_min_dist: u32,
    pub kf_max_dist: u32,
    pub bits_per_second: u32,
    pub intra_period: u32,
}
#[test]
fn bindgen_test_layout__VAEncSequenceParameterBufferVP9() {
    assert_eq!(::std::mem::size_of::<_VAEncSequenceParameterBufferVP9>() ,
               28usize);
    assert_eq!(::std::mem::align_of::<_VAEncSequenceParameterBufferVP9>() ,
               4usize);
}
impl Clone for _VAEncSequenceParameterBufferVP9 {
    fn clone(&self) -> Self { *self }
}
pub type VAEncSequenceParameterBufferVP9 = _VAEncSequenceParameterBufferVP9;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncPictureParameterBufferVP9 {
    pub frame_width_src: u32,
    pub frame_height_src: u32,
    pub frame_width_dst: u32,
    pub frame_height_dst: u32,
    pub reconstructed_frame: VASurfaceID,
    pub reference_frames: [VASurfaceID; 8usize],
    pub coded_buf: VABufferID,
    pub ref_flags: _VAEncPictureParameterBufferVP9__bindgen_ty_1,
    pub pic_flags: _VAEncPictureParameterBufferVP9__bindgen_ty_2,
    pub refresh_frame_flags: u8,
    pub luma_ac_qindex: u8,
    pub luma_dc_qindex_delta: i8,
    pub chroma_ac_qindex_delta: i8,
    pub chroma_dc_qindex_delta: i8,
    pub filter_level: u8,
    pub sharpness_level: u8,
    pub ref_lf_delta: [i8; 4usize],
    pub mode_lf_delta: [i8; 2usize],
    pub bit_offset_ref_lf_delta: u16,
    pub bit_offset_mode_lf_delta: u16,
    pub bit_offset_lf_level: u16,
    pub bit_offset_qindex: u16,
    pub bit_offset_first_partition_size: u16,
    pub bit_offset_segmentation: u16,
    pub bit_size_segmentation: u16,
    pub log2_tile_rows: u8,
    pub log2_tile_columns: u8,
    pub skip_frame_flag: u8,
    pub number_skip_frames: u8,
    pub skip_frames_size: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncPictureParameterBufferVP9__bindgen_ty_1 {
    pub bits: __BindgenUnionField<_VAEncPictureParameterBufferVP9__bindgen_ty_1__bindgen_ty_1>,
    pub value: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncPictureParameterBufferVP9__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__VAEncPictureParameterBufferVP9__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncPictureParameterBufferVP9__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncPictureParameterBufferVP9__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncPictureParameterBufferVP9__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAEncPictureParameterBufferVP9__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn force_kf(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_force_kf(&mut self, val: u32) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn ref_frame_ctrl_l0(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (14usize as u32)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_ref_frame_ctrl_l0(&mut self, val: u32) {
        self._bitfield_1 &= !(14usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (14usize as u32);
    }
    #[inline]
    pub fn ref_frame_ctrl_l1(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (112usize as u32)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_ref_frame_ctrl_l1(&mut self, val: u32) {
        self._bitfield_1 &= !(112usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (112usize as u32);
    }
    #[inline]
    pub fn ref_last_idx(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (896usize as u32)) >>
                                       7u32) as u32)
        }
    }
    #[inline]
    pub fn set_ref_last_idx(&mut self, val: u32) {
        self._bitfield_1 &= !(896usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 7u32) & (896usize as u32);
    }
    #[inline]
    pub fn ref_last_sign_bias(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1024usize as u32)) >>
                                       10u32) as u32)
        }
    }
    #[inline]
    pub fn set_ref_last_sign_bias(&mut self, val: u32) {
        self._bitfield_1 &= !(1024usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 10u32) & (1024usize as u32);
    }
    #[inline]
    pub fn ref_gf_idx(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (14336usize as u32)) >>
                                       11u32) as u32)
        }
    }
    #[inline]
    pub fn set_ref_gf_idx(&mut self, val: u32) {
        self._bitfield_1 &= !(14336usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 11u32) & (14336usize as u32);
    }
    #[inline]
    pub fn ref_gf_sign_bias(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16384usize as u32)) >>
                                       14u32) as u32)
        }
    }
    #[inline]
    pub fn set_ref_gf_sign_bias(&mut self, val: u32) {
        self._bitfield_1 &= !(16384usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (16384usize as u32);
    }
    #[inline]
    pub fn ref_arf_idx(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (229376usize as u32))
                                       >> 15u32) as u32)
        }
    }
    #[inline]
    pub fn set_ref_arf_idx(&mut self, val: u32) {
        self._bitfield_1 &= !(229376usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 15u32) & (229376usize as u32);
    }
    #[inline]
    pub fn ref_arf_sign_bias(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (262144usize as u32))
                                       >> 18u32) as u32)
        }
    }
    #[inline]
    pub fn set_ref_arf_sign_bias(&mut self, val: u32) {
        self._bitfield_1 &= !(262144usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 18u32) & (262144usize as u32);
    }
    #[inline]
    pub fn temporal_id(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (133693440usize as u32)) >> 19u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_temporal_id(&mut self, val: u32) {
        self._bitfield_1 &= !(133693440usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 19u32) & (133693440usize as u32);
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (4160749568usize as u32)) >> 27u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        self._bitfield_1 &= !(4160749568usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 27u32) & (4160749568usize as u32);
    }
}
#[test]
fn bindgen_test_layout__VAEncPictureParameterBufferVP9__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncPictureParameterBufferVP9__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncPictureParameterBufferVP9__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncPictureParameterBufferVP9__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncPictureParameterBufferVP9__bindgen_ty_2 {
    pub bits: __BindgenUnionField<_VAEncPictureParameterBufferVP9__bindgen_ty_2__bindgen_ty_1>,
    pub value: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncPictureParameterBufferVP9__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__VAEncPictureParameterBufferVP9__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncPictureParameterBufferVP9__bindgen_ty_2__bindgen_ty_1>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncPictureParameterBufferVP9__bindgen_ty_2__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _VAEncPictureParameterBufferVP9__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAEncPictureParameterBufferVP9__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn frame_type(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_frame_type(&mut self, val: u32) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn show_frame(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_show_frame(&mut self, val: u32) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn error_resilient_mode(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_error_resilient_mode(&mut self, val: u32) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn intra_only(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                       3u32) as u32)
        }
    }
    #[inline]
    pub fn set_intra_only(&mut self, val: u32) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn allow_high_precision_mv(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_allow_high_precision_mv(&mut self, val: u32) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn mcomp_filter_type(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (224usize as u32)) >>
                                       5u32) as u32)
        }
    }
    #[inline]
    pub fn set_mcomp_filter_type(&mut self, val: u32) {
        self._bitfield_1 &= !(224usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (224usize as u32);
    }
    #[inline]
    pub fn frame_parallel_decoding_mode(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (256usize as u32)) >>
                                       8u32) as u32)
        }
    }
    #[inline]
    pub fn set_frame_parallel_decoding_mode(&mut self, val: u32) {
        self._bitfield_1 &= !(256usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 8u32) & (256usize as u32);
    }
    #[inline]
    pub fn reset_frame_context(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1536usize as u32)) >>
                                       9u32) as u32)
        }
    }
    #[inline]
    pub fn set_reset_frame_context(&mut self, val: u32) {
        self._bitfield_1 &= !(1536usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 9u32) & (1536usize as u32);
    }
    #[inline]
    pub fn refresh_frame_context(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2048usize as u32)) >>
                                       11u32) as u32)
        }
    }
    #[inline]
    pub fn set_refresh_frame_context(&mut self, val: u32) {
        self._bitfield_1 &= !(2048usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 11u32) & (2048usize as u32);
    }
    #[inline]
    pub fn frame_context_idx(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (12288usize as u32)) >>
                                       12u32) as u32)
        }
    }
    #[inline]
    pub fn set_frame_context_idx(&mut self, val: u32) {
        self._bitfield_1 &= !(12288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (12288usize as u32);
    }
    #[inline]
    pub fn segmentation_enabled(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16384usize as u32)) >>
                                       14u32) as u32)
        }
    }
    #[inline]
    pub fn set_segmentation_enabled(&mut self, val: u32) {
        self._bitfield_1 &= !(16384usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (16384usize as u32);
    }
    #[inline]
    pub fn segmentation_temporal_update(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32768usize as u32)) >>
                                       15u32) as u32)
        }
    }
    #[inline]
    pub fn set_segmentation_temporal_update(&mut self, val: u32) {
        self._bitfield_1 &= !(32768usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 15u32) & (32768usize as u32);
    }
    #[inline]
    pub fn segmentation_update_map(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (65536usize as u32)) >>
                                       16u32) as u32)
        }
    }
    #[inline]
    pub fn set_segmentation_update_map(&mut self, val: u32) {
        self._bitfield_1 &= !(65536usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (65536usize as u32);
    }
    #[inline]
    pub fn lossless_mode(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (131072usize as u32))
                                       >> 17u32) as u32)
        }
    }
    #[inline]
    pub fn set_lossless_mode(&mut self, val: u32) {
        self._bitfield_1 &= !(131072usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 17u32) & (131072usize as u32);
    }
    #[inline]
    pub fn comp_prediction_mode(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (786432usize as u32))
                                       >> 18u32) as u32)
        }
    }
    #[inline]
    pub fn set_comp_prediction_mode(&mut self, val: u32) {
        self._bitfield_1 &= !(786432usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 18u32) & (786432usize as u32);
    }
    #[inline]
    pub fn auto_segmentation(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1048576usize as u32))
                                       >> 20u32) as u32)
        }
    }
    #[inline]
    pub fn set_auto_segmentation(&mut self, val: u32) {
        self._bitfield_1 &= !(1048576usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 20u32) & (1048576usize as u32);
    }
    #[inline]
    pub fn super_frame_flag(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2097152usize as u32))
                                       >> 21u32) as u32)
        }
    }
    #[inline]
    pub fn set_super_frame_flag(&mut self, val: u32) {
        self._bitfield_1 &= !(2097152usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 21u32) & (2097152usize as u32);
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (4290772992usize as u32)) >> 22u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        self._bitfield_1 &= !(4290772992usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 22u32) & (4290772992usize as u32);
    }
}
#[test]
fn bindgen_test_layout__VAEncPictureParameterBufferVP9__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<_VAEncPictureParameterBufferVP9__bindgen_ty_2>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncPictureParameterBufferVP9__bindgen_ty_2>()
               , 4usize);
}
impl Clone for _VAEncPictureParameterBufferVP9__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VAEncPictureParameterBufferVP9() {
    assert_eq!(::std::mem::size_of::<_VAEncPictureParameterBufferVP9>() ,
               100usize);
    assert_eq!(::std::mem::align_of::<_VAEncPictureParameterBufferVP9>() ,
               4usize);
}
impl Clone for _VAEncPictureParameterBufferVP9 {
    fn clone(&self) -> Self { *self }
}
pub type VAEncPictureParameterBufferVP9 = _VAEncPictureParameterBufferVP9;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSegParamVP9 {
    pub seg_flags: _VAEncSegParamVP9__bindgen_ty_1,
    pub segment_lf_level_delta: i8,
    pub segment_qindex_delta: i16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSegParamVP9__bindgen_ty_1 {
    pub bits: __BindgenUnionField<_VAEncSegParamVP9__bindgen_ty_1__bindgen_ty_1>,
    pub value: __BindgenUnionField<u8>,
    pub bindgen_union_field: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncSegParamVP9__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout__VAEncSegParamVP9__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncSegParamVP9__bindgen_ty_1__bindgen_ty_1>()
               , 1usize);
    assert_eq!(::std::mem::align_of::<_VAEncSegParamVP9__bindgen_ty_1__bindgen_ty_1>()
               , 1usize);
}
impl Clone for _VAEncSegParamVP9__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl _VAEncSegParamVP9__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn segment_reference_enabled(&self) -> u8 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                       0u32) as u8)
        }
    }
    #[inline]
    pub fn set_segment_reference_enabled(&mut self, val: u8) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn segment_reference(&self) -> u8 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (6usize as u8)) >>
                                       1u32) as u8)
        }
    }
    #[inline]
    pub fn set_segment_reference(&mut self, val: u8) {
        self._bitfield_1 &= !(6usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 1u32) & (6usize as u8);
    }
    #[inline]
    pub fn segment_reference_skipped(&self) -> u8 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8usize as u8)) >>
                                       3u32) as u8)
        }
    }
    #[inline]
    pub fn set_segment_reference_skipped(&mut self, val: u8) {
        self._bitfield_1 &= !(8usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 3u32) & (8usize as u8);
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (240usize as u8)) >>
                                       4u32) as u8)
        }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        self._bitfield_1 &= !(240usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 4u32) & (240usize as u8);
    }
}
#[test]
fn bindgen_test_layout__VAEncSegParamVP9__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VAEncSegParamVP9__bindgen_ty_1>() ,
               1usize);
    assert_eq!(::std::mem::align_of::<_VAEncSegParamVP9__bindgen_ty_1>() ,
               1usize);
}
impl Clone for _VAEncSegParamVP9__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VAEncSegParamVP9() {
    assert_eq!(::std::mem::size_of::<_VAEncSegParamVP9>() , 4usize);
    assert_eq!(::std::mem::align_of::<_VAEncSegParamVP9>() , 2usize);
}
impl Clone for _VAEncSegParamVP9 {
    fn clone(&self) -> Self { *self }
}
pub type VAEncSegParamVP9 = _VAEncSegParamVP9;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAEncMiscParameterTypeVP9PerSegmantParam {
    pub seg_data: [VAEncSegParamVP9; 8usize],
}
#[test]
fn bindgen_test_layout__VAEncMiscParameterTypeVP9PerSegmantParam() {
    assert_eq!(::std::mem::size_of::<_VAEncMiscParameterTypeVP9PerSegmantParam>()
               , 32usize);
    assert_eq!(::std::mem::align_of::<_VAEncMiscParameterTypeVP9PerSegmantParam>()
               , 2usize);
}
impl Clone for _VAEncMiscParameterTypeVP9PerSegmantParam {
    fn clone(&self) -> Self { *self }
}
pub type VAEncMiscParameterTypeVP9PerSegmantParam =
    _VAEncMiscParameterTypeVP9PerSegmantParam;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _VAProcFilterType {
    VAProcFilterNone = 0,
    VAProcFilterNoiseReduction = 1,
    VAProcFilterDeinterlacing = 2,
    VAProcFilterSharpening = 3,
    VAProcFilterColorBalance = 4,
    VAProcFilterSkinToneEnhancement = 5,
    VAProcFilterCount = 6,
}
pub use self::_VAProcFilterType as VAProcFilterType;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _VAProcDeinterlacingType {
    VAProcDeinterlacingNone = 0,
    VAProcDeinterlacingBob = 1,
    VAProcDeinterlacingWeave = 2,
    VAProcDeinterlacingMotionAdaptive = 3,
    VAProcDeinterlacingMotionCompensated = 4,
    VAProcDeinterlacingCount = 5,
}
pub use self::_VAProcDeinterlacingType as VAProcDeinterlacingType;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _VAProcColorBalanceType {
    VAProcColorBalanceNone = 0,
    VAProcColorBalanceHue = 1,
    VAProcColorBalanceSaturation = 2,
    VAProcColorBalanceBrightness = 3,
    VAProcColorBalanceContrast = 4,
    VAProcColorBalanceAutoSaturation = 5,
    VAProcColorBalanceAutoBrightness = 6,
    VAProcColorBalanceAutoContrast = 7,
    VAProcColorBalanceCount = 8,
}
pub use self::_VAProcColorBalanceType as VAProcColorBalanceType;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _VAProcColorStandardType {
    VAProcColorStandardNone = 0,
    VAProcColorStandardBT601 = 1,
    VAProcColorStandardBT709 = 2,
    VAProcColorStandardBT470M = 3,
    VAProcColorStandardBT470BG = 4,
    VAProcColorStandardSMPTE170M = 5,
    VAProcColorStandardSMPTE240M = 6,
    VAProcColorStandardGenericFilm = 7,
    VAProcColorStandardCount = 8,
}
pub use self::_VAProcColorStandardType as VAProcColorStandardType;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAProcPipelineCaps {
    pub pipeline_flags: ::std::os::raw::c_uint,
    pub filter_flags: ::std::os::raw::c_uint,
    pub num_forward_references: ::std::os::raw::c_uint,
    pub num_backward_references: ::std::os::raw::c_uint,
    pub input_color_standards: *mut VAProcColorStandardType,
    pub num_input_color_standards: ::std::os::raw::c_uint,
    pub output_color_standards: *mut VAProcColorStandardType,
    pub num_output_color_standards: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__VAProcPipelineCaps() {
    assert_eq!(::std::mem::size_of::<_VAProcPipelineCaps>() , 48usize);
    assert_eq!(::std::mem::align_of::<_VAProcPipelineCaps>() , 8usize);
}
impl Clone for _VAProcPipelineCaps {
    fn clone(&self) -> Self { *self }
}
pub type VAProcPipelineCaps = _VAProcPipelineCaps;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAProcFilterValueRange {
    pub min_value: f32,
    pub max_value: f32,
    pub default_value: f32,
    pub step: f32,
}
#[test]
fn bindgen_test_layout__VAProcFilterValueRange() {
    assert_eq!(::std::mem::size_of::<_VAProcFilterValueRange>() , 16usize);
    assert_eq!(::std::mem::align_of::<_VAProcFilterValueRange>() , 4usize);
}
impl Clone for _VAProcFilterValueRange {
    fn clone(&self) -> Self { *self }
}
pub type VAProcFilterValueRange = _VAProcFilterValueRange;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAProcPipelineParameterBuffer {
    pub surface: VASurfaceID,
    pub surface_region: *const VARectangle,
    pub surface_color_standard: VAProcColorStandardType,
    pub output_region: *const VARectangle,
    pub output_background_color: ::std::os::raw::c_uint,
    pub output_color_standard: VAProcColorStandardType,
    pub pipeline_flags: ::std::os::raw::c_uint,
    pub filter_flags: ::std::os::raw::c_uint,
    pub filters: *mut VABufferID,
    pub num_filters: ::std::os::raw::c_uint,
    pub forward_references: *mut VASurfaceID,
    pub num_forward_references: ::std::os::raw::c_uint,
    pub backward_references: *mut VASurfaceID,
    pub num_backward_references: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__VAProcPipelineParameterBuffer() {
    assert_eq!(::std::mem::size_of::<_VAProcPipelineParameterBuffer>() ,
               96usize);
    assert_eq!(::std::mem::align_of::<_VAProcPipelineParameterBuffer>() ,
               8usize);
}
impl Clone for _VAProcPipelineParameterBuffer {
    fn clone(&self) -> Self { *self }
}
pub type VAProcPipelineParameterBuffer = _VAProcPipelineParameterBuffer;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAProcFilterParameterBufferBase {
    pub type_: VAProcFilterType,
}
#[test]
fn bindgen_test_layout__VAProcFilterParameterBufferBase() {
    assert_eq!(::std::mem::size_of::<_VAProcFilterParameterBufferBase>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<_VAProcFilterParameterBufferBase>() ,
               4usize);
}
impl Clone for _VAProcFilterParameterBufferBase {
    fn clone(&self) -> Self { *self }
}
pub type VAProcFilterParameterBufferBase = _VAProcFilterParameterBufferBase;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAProcFilterParameterBuffer {
    pub type_: VAProcFilterType,
    pub value: f32,
}
#[test]
fn bindgen_test_layout__VAProcFilterParameterBuffer() {
    assert_eq!(::std::mem::size_of::<_VAProcFilterParameterBuffer>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<_VAProcFilterParameterBuffer>() ,
               4usize);
}
impl Clone for _VAProcFilterParameterBuffer {
    fn clone(&self) -> Self { *self }
}
pub type VAProcFilterParameterBuffer = _VAProcFilterParameterBuffer;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAProcFilterParameterBufferDeinterlacing {
    pub type_: VAProcFilterType,
    pub algorithm: VAProcDeinterlacingType,
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__VAProcFilterParameterBufferDeinterlacing() {
    assert_eq!(::std::mem::size_of::<_VAProcFilterParameterBufferDeinterlacing>()
               , 12usize);
    assert_eq!(::std::mem::align_of::<_VAProcFilterParameterBufferDeinterlacing>()
               , 4usize);
}
impl Clone for _VAProcFilterParameterBufferDeinterlacing {
    fn clone(&self) -> Self { *self }
}
pub type VAProcFilterParameterBufferDeinterlacing =
    _VAProcFilterParameterBufferDeinterlacing;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAProcFilterParameterBufferColorBalance {
    pub type_: VAProcFilterType,
    pub attrib: VAProcColorBalanceType,
    pub value: f32,
}
#[test]
fn bindgen_test_layout__VAProcFilterParameterBufferColorBalance() {
    assert_eq!(::std::mem::size_of::<_VAProcFilterParameterBufferColorBalance>()
               , 12usize);
    assert_eq!(::std::mem::align_of::<_VAProcFilterParameterBufferColorBalance>()
               , 4usize);
}
impl Clone for _VAProcFilterParameterBufferColorBalance {
    fn clone(&self) -> Self { *self }
}
pub type VAProcFilterParameterBufferColorBalance =
    _VAProcFilterParameterBufferColorBalance;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAProcFilterCap {
    pub range: VAProcFilterValueRange,
}
#[test]
fn bindgen_test_layout__VAProcFilterCap() {
    assert_eq!(::std::mem::size_of::<_VAProcFilterCap>() , 16usize);
    assert_eq!(::std::mem::align_of::<_VAProcFilterCap>() , 4usize);
}
impl Clone for _VAProcFilterCap {
    fn clone(&self) -> Self { *self }
}
pub type VAProcFilterCap = _VAProcFilterCap;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAProcFilterCapDeinterlacing {
    pub type_: VAProcDeinterlacingType,
}
#[test]
fn bindgen_test_layout__VAProcFilterCapDeinterlacing() {
    assert_eq!(::std::mem::size_of::<_VAProcFilterCapDeinterlacing>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<_VAProcFilterCapDeinterlacing>() ,
               4usize);
}
impl Clone for _VAProcFilterCapDeinterlacing {
    fn clone(&self) -> Self { *self }
}
pub type VAProcFilterCapDeinterlacing = _VAProcFilterCapDeinterlacing;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VAProcFilterCapColorBalance {
    pub type_: VAProcColorBalanceType,
    pub range: VAProcFilterValueRange,
}
#[test]
fn bindgen_test_layout__VAProcFilterCapColorBalance() {
    assert_eq!(::std::mem::size_of::<_VAProcFilterCapColorBalance>() ,
               20usize);
    assert_eq!(::std::mem::align_of::<_VAProcFilterCapColorBalance>() ,
               4usize);
}
impl Clone for _VAProcFilterCapColorBalance {
    fn clone(&self) -> Self { *self }
}
pub type VAProcFilterCapColorBalance = _VAProcFilterCapColorBalance;
extern "C" {
    pub fn vaQueryVideoProcFilters(dpy: VADisplay, context: VAContextID,
                                   filters: *mut VAProcFilterType,
                                   num_filters: *mut ::std::os::raw::c_uint)
     -> VAStatus;
}
extern "C" {
    pub fn vaQueryVideoProcFilterCaps(dpy: VADisplay, context: VAContextID,
                                      type_: VAProcFilterType,
                                      filter_caps:
                                          *mut ::std::os::raw::c_void,
                                      num_filter_caps:
                                          *mut ::std::os::raw::c_uint)
     -> VAStatus;
}
extern "C" {
    pub fn vaQueryVideoProcPipelineCaps(dpy: VADisplay, context: VAContextID,
                                        filters: *mut VABufferID,
                                        num_filters: ::std::os::raw::c_uint,
                                        pipeline_caps:
                                            *mut VAProcPipelineCaps)
     -> VAStatus;
}
